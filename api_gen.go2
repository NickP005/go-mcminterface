// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package api

import (
	"fmt"
	"net/http"

	"github.com/go-chi/chi/v5"
)

// Defines values for AllowBalanceExemptionsExemptionType.
const (
	Dynamic        AllowBalanceExemptionsExemptionType = "dynamic"
	GreaterOrEqual AllowBalanceExemptionsExemptionType = "greater_or_equal"
	LessOrEqual    AllowBalanceExemptionsExemptionType = "less_or_equal"
)

// Defines values for AllowBlockHashCase.
const (
	AllowBlockHashCaseCaseSensitive AllowBlockHashCase = "case_sensitive"
	AllowBlockHashCaseLowerCase     AllowBlockHashCase = "lower_case"
	AllowBlockHashCaseNil           AllowBlockHashCase = "<nil>"
	AllowBlockHashCaseUpperCase     AllowBlockHashCase = "upper_case"
)

// Defines values for AllowTransactionHashCase.
const (
	AllowTransactionHashCaseCaseSensitive AllowTransactionHashCase = "case_sensitive"
	AllowTransactionHashCaseLowerCase     AllowTransactionHashCase = "lower_case"
	AllowTransactionHashCaseNil           AllowTransactionHashCase = "<nil>"
	AllowTransactionHashCaseUpperCase     AllowTransactionHashCase = "upper_case"
)

// Defines values for BlockTransactionsOperationsCoinChangeCoinAction.
const (
	BlockTransactionsOperationsCoinChangeCoinActionCoinCreated BlockTransactionsOperationsCoinChangeCoinAction = "coin_created"
	BlockTransactionsOperationsCoinChangeCoinActionCoinSpent   BlockTransactionsOperationsCoinChangeCoinAction = "coin_spent"
)

// Defines values for BlockTransactionsRelatedTransactionsDirection.
const (
	BlockTransactionsRelatedTransactionsDirectionBackward BlockTransactionsRelatedTransactionsDirection = "backward"
	BlockTransactionsRelatedTransactionsDirectionForward  BlockTransactionsRelatedTransactionsDirection = "forward"
)

// Defines values for BlockEventType.
const (
	BlockAdded   BlockEventType = "block_added"
	BlockRemoved BlockEventType = "block_removed"
)

// Defines values for BlockTransactionTransactionOperationsCoinChangeCoinAction.
const (
	BlockTransactionTransactionOperationsCoinChangeCoinActionCoinCreated BlockTransactionTransactionOperationsCoinChangeCoinAction = "coin_created"
	BlockTransactionTransactionOperationsCoinChangeCoinActionCoinSpent   BlockTransactionTransactionOperationsCoinChangeCoinAction = "coin_spent"
)

// Defines values for BlockTransactionTransactionRelatedTransactionsDirection.
const (
	BlockTransactionTransactionRelatedTransactionsDirectionBackward BlockTransactionTransactionRelatedTransactionsDirection = "backward"
	BlockTransactionTransactionRelatedTransactionsDirectionForward  BlockTransactionTransactionRelatedTransactionsDirection = "forward"
)

// Defines values for OperationCoinChangeCoinAction.
const (
	OperationCoinChangeCoinActionCoinCreated OperationCoinChangeCoinAction = "coin_created"
	OperationCoinChangeCoinActionCoinSpent   OperationCoinChangeCoinAction = "coin_spent"
)

// Defines values for Operator.
const (
	And Operator = "and"
	Or  Operator = "or"
)

// Defines values for PublicKeyCurveType.
const (
	PublicKeyCurveTypeEdwards25519    PublicKeyCurveType = "edwards25519"
	PublicKeyCurveTypePallas          PublicKeyCurveType = "pallas"
	PublicKeyCurveTypeSecp256k1       PublicKeyCurveType = "secp256k1"
	PublicKeyCurveTypeSecp256k1Bip340 PublicKeyCurveType = "secp256k1_bip340"
	PublicKeyCurveTypeSecp256r1       PublicKeyCurveType = "secp256r1"
	PublicKeyCurveTypeTweedle         PublicKeyCurveType = "tweedle"
)

// Defines values for SignaturePublicKeyCurveType.
const (
	SignaturePublicKeyCurveTypeEdwards25519    SignaturePublicKeyCurveType = "edwards25519"
	SignaturePublicKeyCurveTypePallas          SignaturePublicKeyCurveType = "pallas"
	SignaturePublicKeyCurveTypeSecp256k1       SignaturePublicKeyCurveType = "secp256k1"
	SignaturePublicKeyCurveTypeSecp256k1Bip340 SignaturePublicKeyCurveType = "secp256k1_bip340"
	SignaturePublicKeyCurveTypeSecp256r1       SignaturePublicKeyCurveType = "secp256r1"
	SignaturePublicKeyCurveTypeTweedle         SignaturePublicKeyCurveType = "tweedle"
)

// Defines values for SignatureSignatureType.
const (
	SignatureSignatureTypeEcdsa           SignatureSignatureType = "ecdsa"
	SignatureSignatureTypeEcdsaRecovery   SignatureSignatureType = "ecdsa_recovery"
	SignatureSignatureTypeEd25519         SignatureSignatureType = "ed25519"
	SignatureSignatureTypeSchnorr1        SignatureSignatureType = "schnorr_1"
	SignatureSignatureTypeSchnorrBip340   SignatureSignatureType = "schnorr_bip340"
	SignatureSignatureTypeSchnorrPoseidon SignatureSignatureType = "schnorr_poseidon"
)

// Defines values for SignatureSigningPayloadSignatureType.
const (
	SignatureSigningPayloadSignatureTypeEcdsa           SignatureSigningPayloadSignatureType = "ecdsa"
	SignatureSigningPayloadSignatureTypeEcdsaRecovery   SignatureSigningPayloadSignatureType = "ecdsa_recovery"
	SignatureSigningPayloadSignatureTypeEd25519         SignatureSigningPayloadSignatureType = "ed25519"
	SignatureSigningPayloadSignatureTypeSchnorr1        SignatureSigningPayloadSignatureType = "schnorr_1"
	SignatureSigningPayloadSignatureTypeSchnorrBip340   SignatureSigningPayloadSignatureType = "schnorr_bip340"
	SignatureSigningPayloadSignatureTypeSchnorrPoseidon SignatureSigningPayloadSignatureType = "schnorr_poseidon"
)

// Defines values for SigningPayloadSignatureType.
const (
	Ecdsa           SigningPayloadSignatureType = "ecdsa"
	EcdsaRecovery   SigningPayloadSignatureType = "ecdsa_recovery"
	Ed25519         SigningPayloadSignatureType = "ed25519"
	Schnorr1        SigningPayloadSignatureType = "schnorr_1"
	SchnorrBip340   SigningPayloadSignatureType = "schnorr_bip340"
	SchnorrPoseidon SigningPayloadSignatureType = "schnorr_poseidon"
)

// Defines values for TransactionOperationsCoinChangeCoinAction.
const (
	TransactionOperationsCoinChangeCoinActionCoinCreated TransactionOperationsCoinChangeCoinAction = "coin_created"
	TransactionOperationsCoinChangeCoinActionCoinSpent   TransactionOperationsCoinChangeCoinAction = "coin_spent"
)

// Defines values for TransactionRelatedTransactionsDirection.
const (
	Backward TransactionRelatedTransactionsDirection = "backward"
	Forward  TransactionRelatedTransactionsDirection = "forward"
)

// AccountBalanceRequest An AccountBalanceRequest is utilized to make a balance request
// on the /account/balance endpoint. If the block_identifier is populated,
// a historical balance query should be performed.
type AccountBalanceRequest struct {
	// AccountIdentifier The account_identifier uniquely identifies an account within a network.
	// All fields in the account_identifier are utilized to determine this uniqueness
	// (including the metadata field, if populated).
	AccountIdentifier AccountIdentifier `json:"account_identifier"`

	// BlockIdentifier When fetching data by BlockIdentifier, it may be possible to only specify the
	// index or hash. If neither property is specified, it is assumed that the
	// client is making a request at the current block.
	BlockIdentifier *PartialBlockIdentifier `json:"block_identifier,omitempty"`

	// Currencies In some cases, the caller may not want to retrieve all available
	// balances for an AccountIdentifier. If the currencies field
	// is populated, only balances for the specified currencies
	// will be returned. If not populated, all available balances
	// will be returned.
	Currencies *[]Currency `json:"currencies,omitempty"`

	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`
}

// AccountBalanceResponse An AccountBalanceResponse is returned on the /account/balance endpoint.
// If an account has a balance for each AccountIdentifier describing it
// (ex: an ERC-20 token balance on a few smart contracts), an account
// balance request must be made with each AccountIdentifier.
//
// The `coins` field was removed and replaced by by `/account/coins` in `v1.4.7`.
type AccountBalanceResponse struct {
	// Balances A single account may have a balance in multiple currencies.
	Balances []Amount `json:"balances"`

	// BlockIdentifier The block_identifier uniquely identifies a block in a particular network.
	BlockIdentifier BlockIdentifier `json:"block_identifier"`

	// Metadata Account-based blockchains that utilize a nonce or sequence number
	// should include that number in the metadata. This number could be
	// unique to the identifier or global across the account address.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// AccountCoinsRequest AccountCoinsRequest is utilized to make a request on the /account/coins
// endpoint.
type AccountCoinsRequest struct {
	// AccountIdentifier The account_identifier uniquely identifies an account within a network.
	// All fields in the account_identifier are utilized to determine this uniqueness
	// (including the metadata field, if populated).
	AccountIdentifier AccountIdentifier `json:"account_identifier"`

	// Currencies In some cases, the caller may not want to retrieve coins for all
	// currencies for an AccountIdentifier. If the currencies field
	// is populated, only coins for the specified currencies
	// will be returned. If not populated, all unspent coins
	// will be returned.
	Currencies *[]Currency `json:"currencies,omitempty"`

	// IncludeMempool Include state from the mempool when looking up an account's
	// unspent coins. Note, using this functionality
	// breaks any guarantee of idempotency.
	IncludeMempool bool `json:"include_mempool"`

	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`
}

// AccountCoinsResponse AccountCoinsResponse is returned on the /account/coins endpoint and includes
// all unspent Coins owned by an AccountIdentifier.
type AccountCoinsResponse struct {
	// BlockIdentifier The block_identifier uniquely identifies a block in a particular network.
	BlockIdentifier BlockIdentifier `json:"block_identifier"`

	// Coins If a blockchain is UTXO-based, all unspent Coins owned by an account_identifier
	// should be returned alongside the balance. It is highly recommended to
	// populate this field so that users of the Rosetta API implementation
	// don't need to maintain their own indexer to track their UTXOs.
	Coins []Coin `json:"coins"`

	// Metadata Account-based blockchains that utilize a nonce or sequence number
	// should include that number in the metadata. This number could be
	// unique to the identifier or global across the account address.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// AccountIdentifier The account_identifier uniquely identifies an account within a network.
// All fields in the account_identifier are utilized to determine this uniqueness
// (including the metadata field, if populated).
type AccountIdentifier struct {
	// Address The address may be a cryptographic public key (or some encoding of it) or a provided username.
	Address string `json:"address"`

	// Metadata Blockchains that utilize a username model (where the address is not a derivative of a cryptographic
	// public key) should specify the public key(s) owned by the address in metadata.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// SubAccount An account may have state specific to a contract address (ERC-20 token)
	// and/or a stake (delegated balance). The sub_account_identifier should
	// specify which state (if applicable) an account instantiation refers to.
	SubAccount *struct {
		// Address The SubAccount address may be a cryptographic value or some
		// other identifier (ex: bonded) that uniquely specifies a SubAccount.
		Address string `json:"address"`

		// Metadata If the SubAccount address is not sufficient to uniquely specify a SubAccount,
		// any other identifying information can be stored here.
		//
		// It is important to note that two SubAccounts with identical addresses but
		// differing metadata will not be considered equal by clients.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`
	} `json:"sub_account,omitempty"`
}

// Allow Allow specifies supported Operation status, Operation types,
// and all possible error statuses. This Allow object is used by
// clients to validate the correctness of a Rosetta Server implementation. It is
// expected that these clients will error if they receive some response
// that contains any of the above information that is not specified here.
type Allow struct {
	// BalanceExemptions BalanceExemptions is an array of BalanceExemption indicating
	// which account balances could change without a corresponding Operation.
	//
	// BalanceExemptions should be used sparingly as they may
	// introduce significant complexity for integrators that attempt
	// to reconcile all account balance changes.
	//
	// If your implementation relies on any BalanceExemptions, you MUST implement
	// historical balance lookup (the ability to query an account balance at any
	// BlockIdentifier).
	BalanceExemptions []struct {
		// Currency Currency is composed of a canonical Symbol and
		// Decimals. This Decimals value is used to convert
		// an Amount.Value from atomic units (Satoshis) to standard units
		// (Bitcoins).
		Currency *struct {
			// Decimals Number of decimal places in the standard unit representation of the amount.
			//
			// For example, BTC has 8 decimals. Note that it is not possible to represent
			// the value of some currency in atomic units that is not base 10.
			Decimals int32 `json:"decimals"`

			// Metadata Any additional information related to the currency itself.
			//
			// For example, it would be useful to populate this object with the contract address
			// of an ERC-20 token.
			Metadata *map[string]interface{} `json:"metadata,omitempty"`

			// Symbol Canonical symbol associated with a currency.
			Symbol string `json:"symbol"`
		} `json:"currency,omitempty"`

		// ExemptionType ExemptionType is used to indicate if the live balance for an
		// account subject to a BalanceExemption could increase above,
		// decrease below, or equal the computed balance.
		//
		// * greater_or_equal: The live balance may increase above or equal the computed balance. This typically
		//   occurs with staking rewards that accrue on each block.
		// * less_or_equal: The live balance may decrease below or equal the computed balance. This typically
		//   occurs as balance moves from locked to spendable on a vesting account.
		// * dynamic: The live balance may increase above, decrease below, or equal the computed balance. This
		//   typically occurs with tokens that have a dynamic supply.
		ExemptionType *AllowBalanceExemptionsExemptionType `json:"exemption_type,omitempty"`

		// SubAccountAddress SubAccountAddress is the SubAccountIdentifier.Address that the
		// BalanceExemption applies to (regardless of the value of
		// SubAccountIdentifier.Metadata).
		SubAccountAddress *string `json:"sub_account_address,omitempty"`
	} `json:"balance_exemptions"`

	// BlockHashCase Case specifies the expected case for strings and hashes.
	BlockHashCase *AllowBlockHashCase `json:"block_hash_case"`

	// CallMethods All methods that are supported by the /call endpoint. Communicating
	// which parameters should be provided to /call is the responsibility
	// of the implementer (this is en lieu of defining an entire type
	// system and requiring the implementer to define that in Allow).
	CallMethods []string `json:"call_methods"`

	// Errors All Errors that this implementation could return. Any error
	// that is returned during parsing that is not listed here will
	// cause client validation to error.
	Errors []struct {
		// Code Code is a network-specific error code. If desired, this code
		// can be equivalent to an HTTP status code.
		Code int32 `json:"code"`

		// Description Description allows the implementer to optionally provide additional information
		// about an error. In many cases, the content of this field will be a copy-and-paste
		// from existing developer documentation.
		//
		// Description can ONLY be populated with generic information about a particular
		// type of error. It MUST NOT be populated with information about a particular
		// instantiation of an error (use `details` for this).
		//
		// Whereas the content of Error.Message should stay stable across releases, the
		// content of Error.Description will likely change across releases (as implementers
		// improve error documentation). For this reason, the content in this field
		// is not part of any type assertion (unlike Error.Message).
		Description *string `json:"description,omitempty"`

		// Details Often times it is useful to return context specific
		// to the request that caused the error (i.e. a sample of the
		// stack trace or impacted account) in addition to the
		// standard error message.
		Details *map[string]interface{} `json:"details,omitempty"`

		// Message Message is a network-specific error message.
		//
		// The message MUST NOT change for a given code. In particular, this
		// means that any contextual information should be included in
		// the details field.
		Message string `json:"message"`

		// Retriable An error is retriable if the same request may succeed if submitted
		// again.
		Retriable bool `json:"retriable"`
	} `json:"errors"`

	// HistoricalBalanceLookup Any Rosetta implementation that supports querying the balance
	// of an account at any height in the past should set this to true.
	HistoricalBalanceLookup bool `json:"historical_balance_lookup"`

	// MempoolCoins Any Rosetta implementation that can update an AccountIdentifier's unspent
	// coins based on the contents of the mempool should populate this field
	// as true. If false, requests to `/account/coins` that set `include_mempool`
	// as true will be automatically rejected.
	MempoolCoins bool `json:"mempool_coins"`

	// OperationStatuses All Operation.Status this implementation supports. Any status
	// that is returned during parsing that is not listed here will cause
	// client validation to error.
	OperationStatuses []struct {
		// Status The status is the network-specific status of the operation.
		Status string `json:"status"`

		// Successful An Operation is considered successful if the Operation.Amount
		// should affect the Operation.Account. Some blockchains (like Bitcoin)
		// only include successful operations in blocks but other blockchains
		// (like Ethereum) include unsuccessful operations that incur a fee.
		//
		// To reconcile the computed balance from the stream of Operations,
		// it is critical to understand which Operation.Status indicate an
		// Operation is successful and should affect an Account.
		Successful bool `json:"successful"`
	} `json:"operation_statuses"`

	// OperationTypes All Operation.Type this implementation supports. Any type
	// that is returned during parsing that is not listed here will
	// cause client validation to error.
	OperationTypes []string `json:"operation_types"`

	// TimestampStartIndex If populated, `timestamp_start_index` indicates the first block index
	// where block timestamps are considered valid (i.e. all blocks
	// less than `timestamp_start_index` could have invalid timestamps).
	// This is useful when the genesis block (or blocks) of a network
	// have timestamp 0.
	//
	// If not populated, block timestamps are assumed to be valid for
	// all available blocks.
	TimestampStartIndex *int64 `json:"timestamp_start_index,omitempty"`

	// TransactionHashCase Case specifies the expected case for strings and hashes.
	TransactionHashCase *AllowTransactionHashCase `json:"transaction_hash_case"`
}

// AllowBalanceExemptionsExemptionType ExemptionType is used to indicate if the live balance for an
// account subject to a BalanceExemption could increase above,
// decrease below, or equal the computed balance.
//
//   - greater_or_equal: The live balance may increase above or equal the computed balance. This typically
//     occurs with staking rewards that accrue on each block.
//   - less_or_equal: The live balance may decrease below or equal the computed balance. This typically
//     occurs as balance moves from locked to spendable on a vesting account.
//   - dynamic: The live balance may increase above, decrease below, or equal the computed balance. This
//     typically occurs with tokens that have a dynamic supply.
type AllowBalanceExemptionsExemptionType string

// AllowBlockHashCase Case specifies the expected case for strings and hashes.
type AllowBlockHashCase string

// AllowTransactionHashCase Case specifies the expected case for strings and hashes.
type AllowTransactionHashCase string

// Amount Amount is some Value of a Currency.
// It is considered invalid to specify a Value without a Currency.
type Amount struct {
	// Currency Currency is composed of a canonical Symbol and
	// Decimals. This Decimals value is used to convert
	// an Amount.Value from atomic units (Satoshis) to standard units
	// (Bitcoins).
	Currency struct {
		// Decimals Number of decimal places in the standard unit representation of the amount.
		//
		// For example, BTC has 8 decimals. Note that it is not possible to represent
		// the value of some currency in atomic units that is not base 10.
		Decimals int32 `json:"decimals"`

		// Metadata Any additional information related to the currency itself.
		//
		// For example, it would be useful to populate this object with the contract address
		// of an ERC-20 token.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Symbol Canonical symbol associated with a currency.
		Symbol string `json:"symbol"`
	} `json:"currency"`
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Value Value of the transaction in atomic units represented as an arbitrary-sized signed integer.
	//
	// For example, 1 BTC would be represented by a value of 100000000.
	Value string `json:"value"`
}

// Block Blocks contain an array of Transactions that
// occurred at a particular BlockIdentifier.
//
// A hard requirement for blocks returned by Rosetta
// implementations is that they MUST be _inalterable_:
// once a client has requested and received
// a block identified by a specific BlockIndentifier,
// all future calls for that same BlockIdentifier
// must return the same block contents.
type Block struct {
	// BlockIdentifier The block_identifier uniquely identifies a block in a particular network.
	BlockIdentifier struct {
		// Hash This should be normalized according to the case specified in the block_hash_case
		// network options.
		Hash string `json:"hash"`

		// Index This is also known as the block height.
		Index int64 `json:"index"`
	} `json:"block_identifier"`
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ParentBlockIdentifier The block_identifier uniquely identifies a block in a particular network.
	ParentBlockIdentifier struct {
		// Hash This should be normalized according to the case specified in the block_hash_case
		// network options.
		Hash string `json:"hash"`

		// Index This is also known as the block height.
		Index int64 `json:"index"`
	} `json:"parent_block_identifier"`

	// Timestamp The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in
	// milliseconds because some blockchains produce blocks more often than once a second.
	Timestamp    int64 `json:"timestamp"`
	Transactions []struct {
		// Metadata Transactions that are related to other transactions (like a cross-shard transaction) should include
		// the tranaction_identifier of these transactions in the metadata.
		Metadata   *map[string]interface{} `json:"metadata,omitempty"`
		Operations []struct {
			// Account The account_identifier uniquely identifies an account within a network.
			// All fields in the account_identifier are utilized to determine this uniqueness
			// (including the metadata field, if populated).
			Account *struct {
				// Address The address may be a cryptographic public key (or some encoding of it) or a provided username.
				Address string `json:"address"`

				// Metadata Blockchains that utilize a username model (where the address is not a derivative of a cryptographic
				// public key) should specify the public key(s) owned by the address in metadata.
				Metadata *map[string]interface{} `json:"metadata,omitempty"`

				// SubAccount An account may have state specific to a contract address (ERC-20 token)
				// and/or a stake (delegated balance). The sub_account_identifier should
				// specify which state (if applicable) an account instantiation refers to.
				SubAccount *struct {
					// Address The SubAccount address may be a cryptographic value or some
					// other identifier (ex: bonded) that uniquely specifies a SubAccount.
					Address string `json:"address"`

					// Metadata If the SubAccount address is not sufficient to uniquely specify a SubAccount,
					// any other identifying information can be stored here.
					//
					// It is important to note that two SubAccounts with identical addresses but
					// differing metadata will not be considered equal by clients.
					Metadata *map[string]interface{} `json:"metadata,omitempty"`
				} `json:"sub_account,omitempty"`
			} `json:"account,omitempty"`

			// Amount Amount is some Value of a Currency.
			// It is considered invalid to specify a Value without a Currency.
			Amount *struct {
				// Currency Currency is composed of a canonical Symbol and
				// Decimals. This Decimals value is used to convert
				// an Amount.Value from atomic units (Satoshis) to standard units
				// (Bitcoins).
				Currency struct {
					// Decimals Number of decimal places in the standard unit representation of the amount.
					//
					// For example, BTC has 8 decimals. Note that it is not possible to represent
					// the value of some currency in atomic units that is not base 10.
					Decimals int32 `json:"decimals"`

					// Metadata Any additional information related to the currency itself.
					//
					// For example, it would be useful to populate this object with the contract address
					// of an ERC-20 token.
					Metadata *map[string]interface{} `json:"metadata,omitempty"`

					// Symbol Canonical symbol associated with a currency.
					Symbol string `json:"symbol"`
				} `json:"currency"`
				Metadata *map[string]interface{} `json:"metadata,omitempty"`

				// Value Value of the transaction in atomic units represented as an arbitrary-sized signed integer.
				//
				// For example, 1 BTC would be represented by a value of 100000000.
				Value string `json:"value"`
			} `json:"amount,omitempty"`

			// CoinChange CoinChange is used to represent a change in state of
			// a some coin identified by a coin_identifier. This object
			// is part of the Operation model and must be populated for
			// UTXO-based blockchains.
			//
			// Coincidentally, this abstraction of UTXOs allows for supporting
			// both account-based transfers and UTXO-based transfers on the
			// same blockchain (when a transfer is account-based, don't
			// populate this model).
			CoinChange *struct {
				// CoinAction CoinActions are different state changes that a Coin can
				// undergo. When a Coin is created, it is coin_created. When a Coin is
				// spent, it is coin_spent. It is assumed that a single Coin
				// cannot be created or spent more than once.
				CoinAction BlockTransactionsOperationsCoinChangeCoinAction `json:"coin_action"`

				// CoinIdentifier CoinIdentifier uniquely identifies a Coin.
				CoinIdentifier struct {
					// Identifier Identifier should be populated with a globally unique identifier
					// of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
					Identifier string `json:"identifier"`
				} `json:"coin_identifier"`
			} `json:"coin_change,omitempty"`
			Metadata *map[string]interface{} `json:"metadata,omitempty"`

			// OperationIdentifier The operation_identifier uniquely identifies an operation within a transaction.
			OperationIdentifier struct {
				// Index The operation index is used to ensure each operation has a unique identifier within
				// a transaction. This index is only relative to the transaction and NOT GLOBAL. The
				// operations in each transaction should start from index 0.
				//
				// To clarify, there may not be any notion of an operation index in the blockchain being described.
				Index int64 `json:"index"`

				// NetworkIndex Some blockchains specify an operation index that is essential for client use. For example,
				// Bitcoin uses a network_index to identify which UTXO was used in a transaction.
				//
				// network_index should not be populated if there is no notion of an operation index in a
				// blockchain (typically most account-based blockchains).
				NetworkIndex *int64 `json:"network_index,omitempty"`
			} `json:"operation_identifier"`

			// RelatedOperations Restrict referenced related_operations to identifier indices
			// < the current operation_identifier.index. This ensures there
			// exists a clear DAG-structure of relations.
			//
			// Since operations are one-sided, one could imagine relating operations
			// in a single transfer or linking operations in a call tree.
			RelatedOperations *[]struct {
				// Index The operation index is used to ensure each operation has a unique identifier within
				// a transaction. This index is only relative to the transaction and NOT GLOBAL. The
				// operations in each transaction should start from index 0.
				//
				// To clarify, there may not be any notion of an operation index in the blockchain being described.
				Index int64 `json:"index"`

				// NetworkIndex Some blockchains specify an operation index that is essential for client use. For example,
				// Bitcoin uses a network_index to identify which UTXO was used in a transaction.
				//
				// network_index should not be populated if there is no notion of an operation index in a
				// blockchain (typically most account-based blockchains).
				NetworkIndex *int64 `json:"network_index,omitempty"`
			} `json:"related_operations,omitempty"`

			// Status Status is the network-specific status of the operation. Status is not defined on the transaction object
			// because blockchains with smart contracts may have transactions that partially apply (some operations
			// are successful and some are not). Blockchains with atomic transactions (all operations succeed or
			// all operations fail) will have the same status for each operation.
			//
			// On-chain operations (operations retrieved in the `/block` and `/block/transaction` endpoints) MUST have
			// a populated status field (anything on-chain must have succeeded or failed). However, operations provided
			// during transaction construction (often times called "intent" in the documentation) MUST NOT
			// have a populated status field (operations yet to be included on-chain have not yet succeeded or failed).
			Status *string `json:"status,omitempty"`

			// Type Type is the network-specific type of the operation. Ensure that any type that can be returned here is also
			// specified in the NetworkOptionsResponse. This can be very useful to downstream consumers that parse all
			// block data.
			Type string `json:"type"`
		} `json:"operations"`
		RelatedTransactions *[]struct {
			// Direction Used by RelatedTransaction to indicate the direction of the relation (i.e. cross-shard/cross-network sends may
			// reference `backward` to an earlier transaction and async execution may reference `forward`). Can be used to indicate if
			// a transaction relation is from child to parent or the reverse.
			Direction BlockTransactionsRelatedTransactionsDirection `json:"direction"`

			// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
			NetworkIdentifier *struct {
				Blockchain string `json:"blockchain"`

				// Network If a blockchain has a specific chain-id or network identifier, it
				// should go in this field. It is up to the client to determine which
				// network-specific identifier is mainnet or testnet.
				Network string `json:"network"`

				// SubNetworkIdentifier In blockchains with sharded state, the SubNetworkIdentifier
				// is required to query some object on a specific shard. This identifier is
				// optional for all non-sharded blockchains.
				SubNetworkIdentifier *struct {
					Metadata *map[string]interface{} `json:"metadata,omitempty"`
					Network  string                  `json:"network"`
				} `json:"sub_network_identifier,omitempty"`
			} `json:"network_identifier,omitempty"`

			// TransactionIdentifier The transaction_identifier uniquely identifies a transaction in a particular network and block
			// or in the mempool.
			TransactionIdentifier struct {
				// Hash Any transactions that are attributable only to a block (ex: a block event)
				// should use the hash of the block as the identifier.  This should be normalized according to
				// the case specified in the transaction_hash_case in network options.
				Hash string `json:"hash"`
			} `json:"transaction_identifier"`
		} `json:"related_transactions,omitempty"`

		// TransactionIdentifier The transaction_identifier uniquely identifies a transaction in a particular network and block
		// or in the mempool.
		TransactionIdentifier struct {
			// Hash Any transactions that are attributable only to a block (ex: a block event)
			// should use the hash of the block as the identifier.  This should be normalized according to
			// the case specified in the transaction_hash_case in network options.
			Hash string `json:"hash"`
		} `json:"transaction_identifier"`
	} `json:"transactions"`
}

// BlockTransactionsOperationsCoinChangeCoinAction CoinActions are different state changes that a Coin can
// undergo. When a Coin is created, it is coin_created. When a Coin is
// spent, it is coin_spent. It is assumed that a single Coin
// cannot be created or spent more than once.
type BlockTransactionsOperationsCoinChangeCoinAction string

// BlockTransactionsRelatedTransactionsDirection Used by RelatedTransaction to indicate the direction of the relation (i.e. cross-shard/cross-network sends may
// reference `backward` to an earlier transaction and async execution may reference `forward`). Can be used to indicate if
// a transaction relation is from child to parent or the reverse.
type BlockTransactionsRelatedTransactionsDirection string

// BlockEvent BlockEvent represents the addition or removal of a BlockIdentifier
// from storage. Streaming BlockEvents allows lightweight clients to
// update their own state without needing to implement their own syncing logic.
type BlockEvent struct {
	// BlockIdentifier The block_identifier uniquely identifies a block in a particular network.
	BlockIdentifier struct {
		// Hash This should be normalized according to the case specified in the block_hash_case
		// network options.
		Hash string `json:"hash"`

		// Index This is also known as the block height.
		Index int64 `json:"index"`
	} `json:"block_identifier"`

	// Sequence sequence is the unique identifier of a BlockEvent
	// within the context of a NetworkIdentifier.
	Sequence int64 `json:"sequence"`

	// Type BlockEventType determines if a BlockEvent represents the
	// addition or removal of a block.
	Type BlockEventType `json:"type"`
}

// BlockEventType BlockEventType determines if a BlockEvent represents the
// addition or removal of a block.
type BlockEventType string

// BlockIdentifier The block_identifier uniquely identifies a block in a particular network.
type BlockIdentifier struct {
	// Hash This should be normalized according to the case specified in the block_hash_case
	// network options.
	Hash string `json:"hash"`

	// Index This is also known as the block height.
	Index int64 `json:"index"`
}

// BlockRequest A BlockRequest is utilized to make a block request on the
// /block endpoint.
type BlockRequest struct {
	// BlockIdentifier When fetching data by BlockIdentifier, it may be possible to only specify the
	// index or hash. If neither property is specified, it is assumed that the
	// client is making a request at the current block.
	BlockIdentifier PartialBlockIdentifier `json:"block_identifier"`

	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`
}

// BlockResponse A BlockResponse includes a fully-populated block or a partially-populated
// block with a list of other transactions to fetch (other_transactions).
//
// As a result of the consensus algorithm of some blockchains, blocks
// can be omitted (i.e. certain block indices can be skipped). If a query
// for one of these omitted indices is made, the response should not include
// a `Block` object.
//
// It is VERY important to note that blocks MUST still form a canonical,
// connected chain of blocks where each block has a unique index. In other words,
// the `PartialBlockIdentifier` of a block after an omitted block should
// reference the last non-omitted block.
type BlockResponse struct {
	// Block Blocks contain an array of Transactions that
	// occurred at a particular BlockIdentifier.
	//
	// A hard requirement for blocks returned by Rosetta
	// implementations is that they MUST be _inalterable_:
	// once a client has requested and received
	// a block identified by a specific BlockIndentifier,
	// all future calls for that same BlockIdentifier
	// must return the same block contents.
	Block *Block `json:"block,omitempty"`

	// OtherTransactions Some blockchains may require additional transactions to be fetched
	// that weren't returned in the block response
	// (ex: block only returns transaction hashes). For blockchains with a
	// lot of transactions in each block, this
	// can be very useful as consumers can concurrently fetch all
	// transactions returned.
	OtherTransactions *[]TransactionIdentifier `json:"other_transactions,omitempty"`
}

// BlockTransaction BlockTransaction contains a populated Transaction
// and the BlockIdentifier that contains it.
type BlockTransaction struct {
	// BlockIdentifier The block_identifier uniquely identifies a block in a particular network.
	BlockIdentifier struct {
		// Hash This should be normalized according to the case specified in the block_hash_case
		// network options.
		Hash string `json:"hash"`

		// Index This is also known as the block height.
		Index int64 `json:"index"`
	} `json:"block_identifier"`

	// Transaction Transactions contain an array of Operations
	// that are attributable to the same TransactionIdentifier.
	Transaction struct {
		// Metadata Transactions that are related to other transactions (like a cross-shard transaction) should include
		// the tranaction_identifier of these transactions in the metadata.
		Metadata   *map[string]interface{} `json:"metadata,omitempty"`
		Operations []struct {
			// Account The account_identifier uniquely identifies an account within a network.
			// All fields in the account_identifier are utilized to determine this uniqueness
			// (including the metadata field, if populated).
			Account *struct {
				// Address The address may be a cryptographic public key (or some encoding of it) or a provided username.
				Address string `json:"address"`

				// Metadata Blockchains that utilize a username model (where the address is not a derivative of a cryptographic
				// public key) should specify the public key(s) owned by the address in metadata.
				Metadata *map[string]interface{} `json:"metadata,omitempty"`

				// SubAccount An account may have state specific to a contract address (ERC-20 token)
				// and/or a stake (delegated balance). The sub_account_identifier should
				// specify which state (if applicable) an account instantiation refers to.
				SubAccount *struct {
					// Address The SubAccount address may be a cryptographic value or some
					// other identifier (ex: bonded) that uniquely specifies a SubAccount.
					Address string `json:"address"`

					// Metadata If the SubAccount address is not sufficient to uniquely specify a SubAccount,
					// any other identifying information can be stored here.
					//
					// It is important to note that two SubAccounts with identical addresses but
					// differing metadata will not be considered equal by clients.
					Metadata *map[string]interface{} `json:"metadata,omitempty"`
				} `json:"sub_account,omitempty"`
			} `json:"account,omitempty"`

			// Amount Amount is some Value of a Currency.
			// It is considered invalid to specify a Value without a Currency.
			Amount *struct {
				// Currency Currency is composed of a canonical Symbol and
				// Decimals. This Decimals value is used to convert
				// an Amount.Value from atomic units (Satoshis) to standard units
				// (Bitcoins).
				Currency struct {
					// Decimals Number of decimal places in the standard unit representation of the amount.
					//
					// For example, BTC has 8 decimals. Note that it is not possible to represent
					// the value of some currency in atomic units that is not base 10.
					Decimals int32 `json:"decimals"`

					// Metadata Any additional information related to the currency itself.
					//
					// For example, it would be useful to populate this object with the contract address
					// of an ERC-20 token.
					Metadata *map[string]interface{} `json:"metadata,omitempty"`

					// Symbol Canonical symbol associated with a currency.
					Symbol string `json:"symbol"`
				} `json:"currency"`
				Metadata *map[string]interface{} `json:"metadata,omitempty"`

				// Value Value of the transaction in atomic units represented as an arbitrary-sized signed integer.
				//
				// For example, 1 BTC would be represented by a value of 100000000.
				Value string `json:"value"`
			} `json:"amount,omitempty"`

			// CoinChange CoinChange is used to represent a change in state of
			// a some coin identified by a coin_identifier. This object
			// is part of the Operation model and must be populated for
			// UTXO-based blockchains.
			//
			// Coincidentally, this abstraction of UTXOs allows for supporting
			// both account-based transfers and UTXO-based transfers on the
			// same blockchain (when a transfer is account-based, don't
			// populate this model).
			CoinChange *struct {
				// CoinAction CoinActions are different state changes that a Coin can
				// undergo. When a Coin is created, it is coin_created. When a Coin is
				// spent, it is coin_spent. It is assumed that a single Coin
				// cannot be created or spent more than once.
				CoinAction BlockTransactionTransactionOperationsCoinChangeCoinAction `json:"coin_action"`

				// CoinIdentifier CoinIdentifier uniquely identifies a Coin.
				CoinIdentifier struct {
					// Identifier Identifier should be populated with a globally unique identifier
					// of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
					Identifier string `json:"identifier"`
				} `json:"coin_identifier"`
			} `json:"coin_change,omitempty"`
			Metadata *map[string]interface{} `json:"metadata,omitempty"`

			// OperationIdentifier The operation_identifier uniquely identifies an operation within a transaction.
			OperationIdentifier struct {
				// Index The operation index is used to ensure each operation has a unique identifier within
				// a transaction. This index is only relative to the transaction and NOT GLOBAL. The
				// operations in each transaction should start from index 0.
				//
				// To clarify, there may not be any notion of an operation index in the blockchain being described.
				Index int64 `json:"index"`

				// NetworkIndex Some blockchains specify an operation index that is essential for client use. For example,
				// Bitcoin uses a network_index to identify which UTXO was used in a transaction.
				//
				// network_index should not be populated if there is no notion of an operation index in a
				// blockchain (typically most account-based blockchains).
				NetworkIndex *int64 `json:"network_index,omitempty"`
			} `json:"operation_identifier"`

			// RelatedOperations Restrict referenced related_operations to identifier indices
			// < the current operation_identifier.index. This ensures there
			// exists a clear DAG-structure of relations.
			//
			// Since operations are one-sided, one could imagine relating operations
			// in a single transfer or linking operations in a call tree.
			RelatedOperations *[]struct {
				// Index The operation index is used to ensure each operation has a unique identifier within
				// a transaction. This index is only relative to the transaction and NOT GLOBAL. The
				// operations in each transaction should start from index 0.
				//
				// To clarify, there may not be any notion of an operation index in the blockchain being described.
				Index int64 `json:"index"`

				// NetworkIndex Some blockchains specify an operation index that is essential for client use. For example,
				// Bitcoin uses a network_index to identify which UTXO was used in a transaction.
				//
				// network_index should not be populated if there is no notion of an operation index in a
				// blockchain (typically most account-based blockchains).
				NetworkIndex *int64 `json:"network_index,omitempty"`
			} `json:"related_operations,omitempty"`

			// Status Status is the network-specific status of the operation. Status is not defined on the transaction object
			// because blockchains with smart contracts may have transactions that partially apply (some operations
			// are successful and some are not). Blockchains with atomic transactions (all operations succeed or
			// all operations fail) will have the same status for each operation.
			//
			// On-chain operations (operations retrieved in the `/block` and `/block/transaction` endpoints) MUST have
			// a populated status field (anything on-chain must have succeeded or failed). However, operations provided
			// during transaction construction (often times called "intent" in the documentation) MUST NOT
			// have a populated status field (operations yet to be included on-chain have not yet succeeded or failed).
			Status *string `json:"status,omitempty"`

			// Type Type is the network-specific type of the operation. Ensure that any type that can be returned here is also
			// specified in the NetworkOptionsResponse. This can be very useful to downstream consumers that parse all
			// block data.
			Type string `json:"type"`
		} `json:"operations"`
		RelatedTransactions *[]struct {
			// Direction Used by RelatedTransaction to indicate the direction of the relation (i.e. cross-shard/cross-network sends may
			// reference `backward` to an earlier transaction and async execution may reference `forward`). Can be used to indicate if
			// a transaction relation is from child to parent or the reverse.
			Direction BlockTransactionTransactionRelatedTransactionsDirection `json:"direction"`

			// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
			NetworkIdentifier *struct {
				Blockchain string `json:"blockchain"`

				// Network If a blockchain has a specific chain-id or network identifier, it
				// should go in this field. It is up to the client to determine which
				// network-specific identifier is mainnet or testnet.
				Network string `json:"network"`

				// SubNetworkIdentifier In blockchains with sharded state, the SubNetworkIdentifier
				// is required to query some object on a specific shard. This identifier is
				// optional for all non-sharded blockchains.
				SubNetworkIdentifier *struct {
					Metadata *map[string]interface{} `json:"metadata,omitempty"`
					Network  string                  `json:"network"`
				} `json:"sub_network_identifier,omitempty"`
			} `json:"network_identifier,omitempty"`

			// TransactionIdentifier The transaction_identifier uniquely identifies a transaction in a particular network and block
			// or in the mempool.
			TransactionIdentifier struct {
				// Hash Any transactions that are attributable only to a block (ex: a block event)
				// should use the hash of the block as the identifier.  This should be normalized according to
				// the case specified in the transaction_hash_case in network options.
				Hash string `json:"hash"`
			} `json:"transaction_identifier"`
		} `json:"related_transactions,omitempty"`

		// TransactionIdentifier The transaction_identifier uniquely identifies a transaction in a particular network and block
		// or in the mempool.
		TransactionIdentifier struct {
			// Hash Any transactions that are attributable only to a block (ex: a block event)
			// should use the hash of the block as the identifier.  This should be normalized according to
			// the case specified in the transaction_hash_case in network options.
			Hash string `json:"hash"`
		} `json:"transaction_identifier"`
	} `json:"transaction"`
}

// BlockTransactionTransactionOperationsCoinChangeCoinAction CoinActions are different state changes that a Coin can
// undergo. When a Coin is created, it is coin_created. When a Coin is
// spent, it is coin_spent. It is assumed that a single Coin
// cannot be created or spent more than once.
type BlockTransactionTransactionOperationsCoinChangeCoinAction string

// BlockTransactionTransactionRelatedTransactionsDirection Used by RelatedTransaction to indicate the direction of the relation (i.e. cross-shard/cross-network sends may
// reference `backward` to an earlier transaction and async execution may reference `forward`). Can be used to indicate if
// a transaction relation is from child to parent or the reverse.
type BlockTransactionTransactionRelatedTransactionsDirection string

// BlockTransactionRequest A BlockTransactionRequest is used to fetch a Transaction included in a
// block that is not returned in a BlockResponse.
type BlockTransactionRequest struct {
	// BlockIdentifier The block_identifier uniquely identifies a block in a particular network.
	BlockIdentifier BlockIdentifier `json:"block_identifier"`

	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`

	// TransactionIdentifier The transaction_identifier uniquely identifies a transaction in a particular network and block
	// or in the mempool.
	TransactionIdentifier TransactionIdentifier `json:"transaction_identifier"`
}

// BlockTransactionResponse A BlockTransactionResponse contains information about a block transaction.
type BlockTransactionResponse struct {
	// Transaction Transactions contain an array of Operations
	// that are attributable to the same TransactionIdentifier.
	Transaction Transaction `json:"transaction"`
}

// CallRequest CallRequest is the input to the `/call` endpoint.
type CallRequest struct {
	// Method Method is some network-specific procedure call. This method could
	// map to a network-specific RPC endpoint, a method in an SDK generated
	// from a smart contract, or some hybrid of the two.
	//
	// The implementation must define all available methods in the
	// Allow object. However, it is up to the caller to determine
	// which parameters to provide when invoking `/call`.
	Method string `json:"method"`

	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`

	// Parameters Parameters is some network-specific argument for a method. It is
	// up to the caller to determine which parameters to provide when invoking
	// `/call`.
	Parameters map[string]interface{} `json:"parameters"`
}

// CallResponse CallResponse contains the result of a `/call` invocation.
type CallResponse struct {
	// Idempotent Idempotent indicates that if `/call` is invoked with the same
	// CallRequest again, at any point in time, it will return the same
	// CallResponse.
	//
	// Integrators may cache the CallResponse if this is set to true
	// to avoid making unnecessary calls to the Rosetta implementation. For
	// this reason, implementers should be very conservative about returning
	// true here or they could cause issues for the caller.
	Idempotent bool `json:"idempotent"`

	// Result Result contains the result of the `/call` invocation. This result
	// will not be inspected or interpreted by Rosetta tooling and is
	// left to the caller to decode.
	Result map[string]interface{} `json:"result"`
}

// Coin Coin contains its unique identifier and the amount
// it represents.
type Coin struct {
	// Amount Amount is some Value of a Currency.
	// It is considered invalid to specify a Value without a Currency.
	Amount struct {
		// Currency Currency is composed of a canonical Symbol and
		// Decimals. This Decimals value is used to convert
		// an Amount.Value from atomic units (Satoshis) to standard units
		// (Bitcoins).
		Currency struct {
			// Decimals Number of decimal places in the standard unit representation of the amount.
			//
			// For example, BTC has 8 decimals. Note that it is not possible to represent
			// the value of some currency in atomic units that is not base 10.
			Decimals int32 `json:"decimals"`

			// Metadata Any additional information related to the currency itself.
			//
			// For example, it would be useful to populate this object with the contract address
			// of an ERC-20 token.
			Metadata *map[string]interface{} `json:"metadata,omitempty"`

			// Symbol Canonical symbol associated with a currency.
			Symbol string `json:"symbol"`
		} `json:"currency"`
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Value Value of the transaction in atomic units represented as an arbitrary-sized signed integer.
		//
		// For example, 1 BTC would be represented by a value of 100000000.
		Value string `json:"value"`
	} `json:"amount"`

	// CoinIdentifier CoinIdentifier uniquely identifies a Coin.
	CoinIdentifier struct {
		// Identifier Identifier should be populated with a globally unique identifier
		// of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
		Identifier string `json:"identifier"`
	} `json:"coin_identifier"`
}

// CoinIdentifier CoinIdentifier uniquely identifies a Coin.
type CoinIdentifier struct {
	// Identifier Identifier should be populated with a globally unique identifier
	// of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
	Identifier string `json:"identifier"`
}

// ConstructionCombineRequest ConstructionCombineRequest is the input to the `/construction/combine`
// endpoint. It contains the unsigned transaction blob returned by
// `/construction/payloads` and all required signatures to create
// a network transaction.
type ConstructionCombineRequest struct {
	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier   NetworkIdentifier `json:"network_identifier"`
	Signatures          []Signature       `json:"signatures"`
	UnsignedTransaction string            `json:"unsigned_transaction"`
}

// ConstructionCombineResponse ConstructionCombineResponse is returned by `/construction/combine`.
// The network payload will be sent directly to the
// `construction/submit` endpoint.
type ConstructionCombineResponse struct {
	SignedTransaction string `json:"signed_transaction"`
}

// ConstructionDeriveRequest ConstructionDeriveRequest is passed to the `/construction/derive`
// endpoint. Network is provided in the request because some blockchains
// have different address formats for different networks.
// Metadata is provided in the request because some blockchains
// allow for multiple address types (i.e. different address
// for validators vs normal accounts).
type ConstructionDeriveRequest struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`

	// PublicKey PublicKey contains a public key byte array
	// for a particular CurveType encoded in hex.
	//
	// Note that there is no PrivateKey struct as this
	// is NEVER the concern of an implementation.
	PublicKey PublicKey `json:"public_key"`
}

// ConstructionDeriveResponse ConstructionDeriveResponse is returned by the `/construction/derive`
// endpoint.
type ConstructionDeriveResponse struct {
	// AccountIdentifier The account_identifier uniquely identifies an account within a network.
	// All fields in the account_identifier are utilized to determine this uniqueness
	// (including the metadata field, if populated).
	AccountIdentifier *AccountIdentifier `json:"account_identifier,omitempty"`

	// Address [DEPRECATED by `account_identifier` in `v1.4.4`] Address in network-specific format.
	Address  *string                 `json:"address,omitempty"`
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// ConstructionHashRequest ConstructionHashRequest is the input to the `/construction/hash` endpoint.
type ConstructionHashRequest struct {
	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`
	SignedTransaction string            `json:"signed_transaction"`
}

// ConstructionMetadataRequest A ConstructionMetadataRequest is utilized to get information required
// to construct a transaction.
//
// The Options object used to specify which metadata to return is left
// purposely unstructured to allow flexibility for implementers. Options
// is not required in the case that there is network-wide metadata of
// interest.
//
// Optionally, the request can also include an array
// of PublicKeys associated with the AccountIdentifiers
// returned in ConstructionPreprocessResponse.
type ConstructionMetadataRequest struct {
	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`

	// Options Some blockchains require different metadata for different types of
	// transaction construction (ex: delegation versus a transfer). Instead
	// of requiring a blockchain node to return all possible types of
	// metadata for construction (which may require multiple node fetches),
	// the client can populate an options object to limit the metadata
	// returned to only the subset required.
	Options    *map[string]interface{} `json:"options,omitempty"`
	PublicKeys *[]PublicKey            `json:"public_keys,omitempty"`
}

// ConstructionMetadataResponse The ConstructionMetadataResponse returns network-specific metadata
// used for transaction construction.
//
// Optionally, the implementer can return the suggested fee associated
// with the transaction being constructed. The caller may use this info
// to adjust the intent of the transaction or to create a transaction with
// a different account that can pay the suggested fee. Suggested fee is an array
// in case fee payment must occur in multiple currencies.
type ConstructionMetadataResponse struct {
	Metadata     map[string]interface{} `json:"metadata"`
	SuggestedFee *[]Amount              `json:"suggested_fee,omitempty"`
}

// ConstructionParseRequest ConstructionParseRequest is the input to the `/construction/parse`
// endpoint. It allows the caller to parse either an unsigned or
// signed transaction.
type ConstructionParseRequest struct {
	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`

	// Signed Signed is a boolean indicating whether the transaction is signed.
	Signed bool `json:"signed"`

	// Transaction This must be either the unsigned transaction blob returned by
	// `/construction/payloads` or the signed transaction blob
	// returned by `/construction/combine`.
	Transaction string `json:"transaction"`
}

// ConstructionParseResponse ConstructionParseResponse contains an array of operations that occur in
// a transaction blob. This should match the array of operations provided
// to `/construction/preprocess` and `/construction/payloads`.
type ConstructionParseResponse struct {
	AccountIdentifierSigners *[]AccountIdentifier    `json:"account_identifier_signers,omitempty"`
	Metadata                 *map[string]interface{} `json:"metadata,omitempty"`
	Operations               []Operation             `json:"operations"`

	// Signers [DEPRECATED by `account_identifier_signers` in `v1.4.4`] All signers (addresses) of a particular transaction. If the transaction
	// is unsigned, it should be empty.
	Signers *[]string `json:"signers,omitempty"`
}

// ConstructionPayloadsRequest ConstructionPayloadsRequest is the request to
// `/construction/payloads`. It contains the network,
// a slice of operations, and arbitrary metadata
// that was returned by the call to `/construction/metadata`.
//
// Optionally, the request can also include an array
// of PublicKeys associated with the AccountIdentifiers
// returned in ConstructionPreprocessResponse.
type ConstructionPayloadsRequest struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`
	Operations        []Operation       `json:"operations"`
	PublicKeys        *[]PublicKey      `json:"public_keys,omitempty"`
}

// ConstructionPayloadsResponse ConstructionTransactionResponse is returned by `/construction/payloads`. It
// contains an unsigned transaction blob (that is usually needed to construct
// the a network transaction from a collection of signatures) and an
// array of payloads that must be signed by the caller.
type ConstructionPayloadsResponse struct {
	Payloads            []SigningPayload `json:"payloads"`
	UnsignedTransaction string           `json:"unsigned_transaction"`
}

// ConstructionPreprocessRequest ConstructionPreprocessRequest is passed to the `/construction/preprocess`
// endpoint so that a Rosetta implementation can determine which
// metadata it needs to request for construction.
//
// Metadata provided in this object should NEVER be a product
// of live data (i.e. the caller must follow some network-specific
// data fetching strategy outside of the Construction API to populate
// required Metadata). If live data is required for construction, it MUST
// be fetched in the call to `/construction/metadata`.
type ConstructionPreprocessRequest struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`
	Operations        []Operation       `json:"operations"`
}

// ConstructionPreprocessResponse ConstructionPreprocessResponse contains `options` that will
// be sent unmodified to `/construction/metadata`. If it is
// not necessary to make a request to `/construction/metadata`,
// `options` should be omitted.
//
// Some blockchains require the PublicKey of particular AccountIdentifiers
// to construct a valid transaction. To fetch these PublicKeys, populate
// `required_public_keys` with the AccountIdentifiers associated with the desired
// PublicKeys. If it is not necessary to retrieve any PublicKeys
// for construction, `required_public_keys` should be omitted.
type ConstructionPreprocessResponse struct {
	// Options The options that will be sent directly to `/construction/metadata` by
	// the caller.
	Options            *map[string]interface{} `json:"options,omitempty"`
	RequiredPublicKeys *[]AccountIdentifier    `json:"required_public_keys,omitempty"`
}

// ConstructionSubmitRequest The transaction submission request includes a signed transaction.
type ConstructionSubmitRequest struct {
	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`
	SignedTransaction string            `json:"signed_transaction"`
}

// Currency Currency is composed of a canonical Symbol and
// Decimals. This Decimals value is used to convert
// an Amount.Value from atomic units (Satoshis) to standard units
// (Bitcoins).
type Currency struct {
	// Decimals Number of decimal places in the standard unit representation of the amount.
	//
	// For example, BTC has 8 decimals. Note that it is not possible to represent
	// the value of some currency in atomic units that is not base 10.
	Decimals int32 `json:"decimals"`

	// Metadata Any additional information related to the currency itself.
	//
	// For example, it would be useful to populate this object with the contract address
	// of an ERC-20 token.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Symbol Canonical symbol associated with a currency.
	Symbol string `json:"symbol"`
}

// Error Instead of utilizing HTTP status codes to describe node errors (which often
// do not have a good analog), rich errors are returned using this object.
//
// Both the code and message fields can be individually used to correctly
// identify an error. Implementations MUST use unique values for both
// fields.
type Error struct {
	// Code Code is a network-specific error code. If desired, this code
	// can be equivalent to an HTTP status code.
	Code int32 `json:"code"`

	// Description Description allows the implementer to optionally provide additional information
	// about an error. In many cases, the content of this field will be a copy-and-paste
	// from existing developer documentation.
	//
	// Description can ONLY be populated with generic information about a particular
	// type of error. It MUST NOT be populated with information about a particular
	// instantiation of an error (use `details` for this).
	//
	// Whereas the content of Error.Message should stay stable across releases, the
	// content of Error.Description will likely change across releases (as implementers
	// improve error documentation). For this reason, the content in this field
	// is not part of any type assertion (unlike Error.Message).
	Description *string `json:"description,omitempty"`

	// Details Often times it is useful to return context specific
	// to the request that caused the error (i.e. a sample of the
	// stack trace or impacted account) in addition to the
	// standard error message.
	Details *map[string]interface{} `json:"details,omitempty"`

	// Message Message is a network-specific error message.
	//
	// The message MUST NOT change for a given code. In particular, this
	// means that any contextual information should be included in
	// the details field.
	Message string `json:"message"`

	// Retriable An error is retriable if the same request may succeed if submitted
	// again.
	Retriable bool `json:"retriable"`
}

// EventsBlocksRequest EventsBlocksRequest is utilized to fetch a sequence of BlockEvents
// indicating which blocks were added and removed from storage to
// reach the current state.
type EventsBlocksRequest struct {
	// Limit limit is the maximum number of events to fetch in one call. The implementation
	// may return <= limit events.
	Limit *int64 `json:"limit,omitempty"`

	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`

	// Offset offset is the offset into the event stream to sync events from. If this
	// field is not populated, we return the limit events backwards from tip.
	// If this is set to 0, we start from the beginning.
	Offset *int64 `json:"offset,omitempty"`
}

// EventsBlocksResponse EventsBlocksResponse contains an ordered collection of BlockEvents
// and the max retrievable sequence.
type EventsBlocksResponse struct {
	// Events events is an array of BlockEvents indicating the order to add
	// and remove blocks to maintain a canonical view of blockchain
	// state. Lightweight clients can use this event stream to update
	// state without implementing their own block syncing logic.
	Events []BlockEvent `json:"events"`

	// MaxSequence max_sequence is the maximum available sequence number to fetch.
	MaxSequence int64 `json:"max_sequence"`
}

// MempoolResponse A MempoolResponse contains all transaction identifiers in the mempool
// for a particular network_identifier.
type MempoolResponse struct {
	TransactionIdentifiers []TransactionIdentifier `json:"transaction_identifiers"`
}

// MempoolTransactionRequest A MempoolTransactionRequest is utilized to retrieve a transaction
// from the mempool.
type MempoolTransactionRequest struct {
	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`

	// TransactionIdentifier The transaction_identifier uniquely identifies a transaction in a particular network and block
	// or in the mempool.
	TransactionIdentifier TransactionIdentifier `json:"transaction_identifier"`
}

// MempoolTransactionResponse A MempoolTransactionResponse contains an estimate of a mempool
// transaction. It may not be possible to know the full impact of
// a transaction in the mempool (ex: fee paid).
type MempoolTransactionResponse struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Transaction Transactions contain an array of Operations
	// that are attributable to the same TransactionIdentifier.
	Transaction Transaction `json:"transaction"`
}

// MetadataRequest A MetadataRequest is utilized in any request where
// the only argument is optional metadata.
type MetadataRequest struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
type NetworkIdentifier struct {
	Blockchain string `json:"blockchain"`

	// Network If a blockchain has a specific chain-id or network identifier, it
	// should go in this field. It is up to the client to determine which
	// network-specific identifier is mainnet or testnet.
	Network string `json:"network"`

	// SubNetworkIdentifier In blockchains with sharded state, the SubNetworkIdentifier
	// is required to query some object on a specific shard. This identifier is
	// optional for all non-sharded blockchains.
	SubNetworkIdentifier *struct {
		Metadata *map[string]interface{} `json:"metadata,omitempty"`
		Network  string                  `json:"network"`
	} `json:"sub_network_identifier,omitempty"`
}

// NetworkListResponse A NetworkListResponse contains all NetworkIdentifiers
// that the node can serve information for.
type NetworkListResponse struct {
	NetworkIdentifiers []NetworkIdentifier `json:"network_identifiers"`
}

// NetworkOptionsResponse NetworkOptionsResponse contains information about the versioning of the
// node and the allowed operation statuses, operation types, and errors.
type NetworkOptionsResponse struct {
	// Allow Allow specifies supported Operation status, Operation types,
	// and all possible error statuses. This Allow object is used by
	// clients to validate the correctness of a Rosetta Server implementation. It is
	// expected that these clients will error if they receive some response
	// that contains any of the above information that is not specified here.
	Allow Allow `json:"allow"`

	// Version The Version object is utilized to inform the client
	// of the versions of different components of the Rosetta
	// implementation.
	Version Version `json:"version"`
}

// NetworkRequest A NetworkRequest is utilized to retrieve some data specific exclusively
// to a NetworkIdentifier.
type NetworkRequest struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`
}

// NetworkStatusResponse NetworkStatusResponse contains basic information about the node's
// view of a blockchain network. It is assumed that any BlockIdentifier.Index
// less than or equal to CurrentBlockIdentifier.Index can be queried.
//
// If a Rosetta implementation prunes historical state, it should
// populate the optional `oldest_block_identifier` field with the
// oldest block available to query. If this is not populated,
// it is assumed that the `genesis_block_identifier` is the oldest
// queryable block.
//
// If a Rosetta implementation performs some pre-sync before it is
// possible to query blocks, sync_status should be populated so that
// clients can still monitor healthiness. Without this field, it may
// appear that the implementation is stuck syncing and needs to be
// terminated.
type NetworkStatusResponse struct {
	// CurrentBlockIdentifier The block_identifier uniquely identifies a block in a particular network.
	CurrentBlockIdentifier BlockIdentifier `json:"current_block_identifier"`

	// CurrentBlockTimestamp The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in
	// milliseconds because some blockchains produce blocks more often than once a second.
	CurrentBlockTimestamp Timestamp `json:"current_block_timestamp"`

	// GenesisBlockIdentifier The block_identifier uniquely identifies a block in a particular network.
	GenesisBlockIdentifier BlockIdentifier `json:"genesis_block_identifier"`

	// OldestBlockIdentifier The block_identifier uniquely identifies a block in a particular network.
	OldestBlockIdentifier *BlockIdentifier `json:"oldest_block_identifier,omitempty"`
	Peers                 *[]Peer          `json:"peers,omitempty"`

	// SyncStatus SyncStatus is used to provide additional context about an
	// implementation's sync status.
	//
	// This object is often used by implementations to indicate healthiness
	// when block data cannot be queried until some sync phase completes or
	// cannot be determined by comparing the timestamp of the most recent
	// block with the current time.
	SyncStatus *SyncStatus `json:"sync_status,omitempty"`
}

// Operation Operations contain all balance-changing information within a
// transaction. They are always one-sided (only affect 1 AccountIdentifier)
// and can succeed or fail independently from a Transaction.
//
// Operations are used both to represent on-chain data (Data API) and to construct
// new transactions (Construction API), creating a standard interface for reading
// and writing to blockchains.
type Operation struct {
	// Account The account_identifier uniquely identifies an account within a network.
	// All fields in the account_identifier are utilized to determine this uniqueness
	// (including the metadata field, if populated).
	Account *struct {
		// Address The address may be a cryptographic public key (or some encoding of it) or a provided username.
		Address string `json:"address"`

		// Metadata Blockchains that utilize a username model (where the address is not a derivative of a cryptographic
		// public key) should specify the public key(s) owned by the address in metadata.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// SubAccount An account may have state specific to a contract address (ERC-20 token)
		// and/or a stake (delegated balance). The sub_account_identifier should
		// specify which state (if applicable) an account instantiation refers to.
		SubAccount *struct {
			// Address The SubAccount address may be a cryptographic value or some
			// other identifier (ex: bonded) that uniquely specifies a SubAccount.
			Address string `json:"address"`

			// Metadata If the SubAccount address is not sufficient to uniquely specify a SubAccount,
			// any other identifying information can be stored here.
			//
			// It is important to note that two SubAccounts with identical addresses but
			// differing metadata will not be considered equal by clients.
			Metadata *map[string]interface{} `json:"metadata,omitempty"`
		} `json:"sub_account,omitempty"`
	} `json:"account,omitempty"`

	// Amount Amount is some Value of a Currency.
	// It is considered invalid to specify a Value without a Currency.
	Amount *struct {
		// Currency Currency is composed of a canonical Symbol and
		// Decimals. This Decimals value is used to convert
		// an Amount.Value from atomic units (Satoshis) to standard units
		// (Bitcoins).
		Currency struct {
			// Decimals Number of decimal places in the standard unit representation of the amount.
			//
			// For example, BTC has 8 decimals. Note that it is not possible to represent
			// the value of some currency in atomic units that is not base 10.
			Decimals int32 `json:"decimals"`

			// Metadata Any additional information related to the currency itself.
			//
			// For example, it would be useful to populate this object with the contract address
			// of an ERC-20 token.
			Metadata *map[string]interface{} `json:"metadata,omitempty"`

			// Symbol Canonical symbol associated with a currency.
			Symbol string `json:"symbol"`
		} `json:"currency"`
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Value Value of the transaction in atomic units represented as an arbitrary-sized signed integer.
		//
		// For example, 1 BTC would be represented by a value of 100000000.
		Value string `json:"value"`
	} `json:"amount,omitempty"`

	// CoinChange CoinChange is used to represent a change in state of
	// a some coin identified by a coin_identifier. This object
	// is part of the Operation model and must be populated for
	// UTXO-based blockchains.
	//
	// Coincidentally, this abstraction of UTXOs allows for supporting
	// both account-based transfers and UTXO-based transfers on the
	// same blockchain (when a transfer is account-based, don't
	// populate this model).
	CoinChange *struct {
		// CoinAction CoinActions are different state changes that a Coin can
		// undergo. When a Coin is created, it is coin_created. When a Coin is
		// spent, it is coin_spent. It is assumed that a single Coin
		// cannot be created or spent more than once.
		CoinAction OperationCoinChangeCoinAction `json:"coin_action"`

		// CoinIdentifier CoinIdentifier uniquely identifies a Coin.
		CoinIdentifier struct {
			// Identifier Identifier should be populated with a globally unique identifier
			// of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
			Identifier string `json:"identifier"`
		} `json:"coin_identifier"`
	} `json:"coin_change,omitempty"`
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OperationIdentifier The operation_identifier uniquely identifies an operation within a transaction.
	OperationIdentifier struct {
		// Index The operation index is used to ensure each operation has a unique identifier within
		// a transaction. This index is only relative to the transaction and NOT GLOBAL. The
		// operations in each transaction should start from index 0.
		//
		// To clarify, there may not be any notion of an operation index in the blockchain being described.
		Index int64 `json:"index"`

		// NetworkIndex Some blockchains specify an operation index that is essential for client use. For example,
		// Bitcoin uses a network_index to identify which UTXO was used in a transaction.
		//
		// network_index should not be populated if there is no notion of an operation index in a
		// blockchain (typically most account-based blockchains).
		NetworkIndex *int64 `json:"network_index,omitempty"`
	} `json:"operation_identifier"`

	// RelatedOperations Restrict referenced related_operations to identifier indices
	// < the current operation_identifier.index. This ensures there
	// exists a clear DAG-structure of relations.
	//
	// Since operations are one-sided, one could imagine relating operations
	// in a single transfer or linking operations in a call tree.
	RelatedOperations *[]struct {
		// Index The operation index is used to ensure each operation has a unique identifier within
		// a transaction. This index is only relative to the transaction and NOT GLOBAL. The
		// operations in each transaction should start from index 0.
		//
		// To clarify, there may not be any notion of an operation index in the blockchain being described.
		Index int64 `json:"index"`

		// NetworkIndex Some blockchains specify an operation index that is essential for client use. For example,
		// Bitcoin uses a network_index to identify which UTXO was used in a transaction.
		//
		// network_index should not be populated if there is no notion of an operation index in a
		// blockchain (typically most account-based blockchains).
		NetworkIndex *int64 `json:"network_index,omitempty"`
	} `json:"related_operations,omitempty"`

	// Status Status is the network-specific status of the operation. Status is not defined on the transaction object
	// because blockchains with smart contracts may have transactions that partially apply (some operations
	// are successful and some are not). Blockchains with atomic transactions (all operations succeed or
	// all operations fail) will have the same status for each operation.
	//
	// On-chain operations (operations retrieved in the `/block` and `/block/transaction` endpoints) MUST have
	// a populated status field (anything on-chain must have succeeded or failed). However, operations provided
	// during transaction construction (often times called "intent" in the documentation) MUST NOT
	// have a populated status field (operations yet to be included on-chain have not yet succeeded or failed).
	Status *string `json:"status,omitempty"`

	// Type Type is the network-specific type of the operation. Ensure that any type that can be returned here is also
	// specified in the NetworkOptionsResponse. This can be very useful to downstream consumers that parse all
	// block data.
	Type string `json:"type"`
}

// OperationCoinChangeCoinAction CoinActions are different state changes that a Coin can
// undergo. When a Coin is created, it is coin_created. When a Coin is
// spent, it is coin_spent. It is assumed that a single Coin
// cannot be created or spent more than once.
type OperationCoinChangeCoinAction string

// Operator Operator is used by query-related endpoints
// to determine how to apply conditions.
//
// If this field is not populated, the default
// `and` value will be used.
type Operator string

// PartialBlockIdentifier When fetching data by BlockIdentifier, it may be possible to only specify the
// index or hash. If neither property is specified, it is assumed that the
// client is making a request at the current block.
type PartialBlockIdentifier struct {
	Hash  *string `json:"hash,omitempty"`
	Index *int64  `json:"index,omitempty"`
}

// Peer A Peer is a representation of a node's peer.
type Peer struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
	PeerId   string                  `json:"peer_id"`
}

// PublicKey PublicKey contains a public key byte array
// for a particular CurveType encoded in hex.
//
// Note that there is no PrivateKey struct as this
// is NEVER the concern of an implementation.
type PublicKey struct {
	// CurveType CurveType is the type of cryptographic curve associated with a PublicKey.
	//
	// * secp256k1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3)
	// * secp256k1_bip340: x-only - `32 bytes`  (implicitly even `Y` coord. Secp256k1 compressed keys may be repurposed by dropping the first byte. (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Public_Key_Generation))
	// * secp256r1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3)
	// * edwards25519: `y (255-bits) || x-sign-bit (1-bit)` - `32 bytes` (https://ed25519.cr.yp.to/ed25519-20110926.pdf)
	// * tweedle: 1st pk : Fq.t (32 bytes) || 2nd pk : Fq.t (32 bytes) (https://github.com/CodaProtocol/coda/blob/develop/rfcs/0038-rosetta-construction-api.md#marshal-keys)
	// * pallas: `x (255 bits) || y-parity-bit (1-bit) - 32 bytes` (https://github.com/zcash/pasta)
	CurveType PublicKeyCurveType `json:"curve_type"`

	// HexBytes Hex-encoded public key bytes in the format
	// specified by the CurveType.
	HexBytes string `json:"hex_bytes"`
}

// PublicKeyCurveType CurveType is the type of cryptographic curve associated with a PublicKey.
//
// * secp256k1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3)
// * secp256k1_bip340: x-only - `32 bytes`  (implicitly even `Y` coord. Secp256k1 compressed keys may be repurposed by dropping the first byte. (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Public_Key_Generation))
// * secp256r1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3)
// * edwards25519: `y (255-bits) || x-sign-bit (1-bit)` - `32 bytes` (https://ed25519.cr.yp.to/ed25519-20110926.pdf)
// * tweedle: 1st pk : Fq.t (32 bytes) || 2nd pk : Fq.t (32 bytes) (https://github.com/CodaProtocol/coda/blob/develop/rfcs/0038-rosetta-construction-api.md#marshal-keys)
// * pallas: `x (255 bits) || y-parity-bit (1-bit) - 32 bytes` (https://github.com/zcash/pasta)
type PublicKeyCurveType string

// SearchTransactionsRequest SearchTransactionsRequest is used to search for transactions
// matching a set of provided conditions in canonical blocks.
type SearchTransactionsRequest struct {
	// AccountIdentifier The account_identifier uniquely identifies an account within a network.
	// All fields in the account_identifier are utilized to determine this uniqueness
	// (including the metadata field, if populated).
	AccountIdentifier *AccountIdentifier `json:"account_identifier,omitempty"`

	// Address address is AccountIdentifier.Address. This is used to get all
	// transactions related to an AccountIdentifier.Address, regardless
	// of SubAccountIdentifier.
	Address *string `json:"address,omitempty"`

	// CoinIdentifier CoinIdentifier uniquely identifies a Coin.
	CoinIdentifier *CoinIdentifier `json:"coin_identifier,omitempty"`

	// Currency Currency is composed of a canonical Symbol and
	// Decimals. This Decimals value is used to convert
	// an Amount.Value from atomic units (Satoshis) to standard units
	// (Bitcoins).
	Currency *Currency `json:"currency,omitempty"`

	// Limit limit is the maximum number of transactions to return in one call. The implementation
	// may return <= limit transactions.
	Limit *int64 `json:"limit,omitempty"`

	// MaxBlock max_block is the largest block index to consider when searching
	// for transactions. If this field is not populated, the current
	// block is considered the max_block.
	//
	// If you do not specify a max_block, it is possible a newly synced
	// block will interfere with paginated transaction queries (as the offset
	// could become invalid with newly added rows).
	MaxBlock *int64 `json:"max_block,omitempty"`

	// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`

	// Offset offset is the offset into the query result to start returning transactions.
	//
	// If any search conditions are changed, the query offset will change and you
	// must restart your search iteration.
	Offset *int64 `json:"offset,omitempty"`

	// Operator Operator is used by query-related endpoints
	// to determine how to apply conditions.
	//
	// If this field is not populated, the default
	// `and` value will be used.
	Operator *Operator `json:"operator,omitempty"`

	// Status status is the network-specific operation type.
	Status *string `json:"status,omitempty"`

	// Success success is a synthetic condition populated by parsing network-specific
	// operation statuses (using the mapping provided in `/network/options`).
	Success *bool `json:"success,omitempty"`

	// TransactionIdentifier The transaction_identifier uniquely identifies a transaction in a particular network and block
	// or in the mempool.
	TransactionIdentifier *TransactionIdentifier `json:"transaction_identifier,omitempty"`

	// Type type is the network-specific operation type.
	Type *string `json:"type,omitempty"`
}

// SearchTransactionsResponse SearchTransactionsResponse contains an ordered collection of BlockTransactions
// that match the query in SearchTransactionsRequest. These BlockTransactions
// are sorted from most recent block to oldest block.
type SearchTransactionsResponse struct {
	// NextOffset next_offset is the next offset to use when paginating through
	// transaction results. If this field is not populated, there are
	// no more transactions to query.
	NextOffset *int64 `json:"next_offset,omitempty"`

	// TotalCount total_count is the number of results for a given search. Callers
	// typically use this value to concurrently fetch results by offset
	// or to display a virtual page number associated with results.
	TotalCount int64 `json:"total_count"`

	// Transactions transactions is an array of BlockTransactions sorted by most recent
	// BlockIdentifier (meaning that transactions in recent blocks appear
	// first).
	//
	// If there are many transactions for a particular search, transactions
	// may not contain all matching transactions. It is up to the caller to
	// paginate these transactions using the max_block field.
	Transactions []BlockTransaction `json:"transactions"`
}

// Signature Signature contains the payload that was signed, the public keys of the
// keypairs used to produce the signature, the signature (encoded in hex),
// and the SignatureType.
//
// PublicKey is often times not known during construction of the signing payloads
// but may be needed to combine signatures properly.
type Signature struct {
	HexBytes string `json:"hex_bytes"`

	// PublicKey PublicKey contains a public key byte array
	// for a particular CurveType encoded in hex.
	//
	// Note that there is no PrivateKey struct as this
	// is NEVER the concern of an implementation.
	PublicKey struct {
		// CurveType CurveType is the type of cryptographic curve associated with a PublicKey.
		//
		// * secp256k1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3)
		// * secp256k1_bip340: x-only - `32 bytes`  (implicitly even `Y` coord. Secp256k1 compressed keys may be repurposed by dropping the first byte. (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Public_Key_Generation))
		// * secp256r1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3)
		// * edwards25519: `y (255-bits) || x-sign-bit (1-bit)` - `32 bytes` (https://ed25519.cr.yp.to/ed25519-20110926.pdf)
		// * tweedle: 1st pk : Fq.t (32 bytes) || 2nd pk : Fq.t (32 bytes) (https://github.com/CodaProtocol/coda/blob/develop/rfcs/0038-rosetta-construction-api.md#marshal-keys)
		// * pallas: `x (255 bits) || y-parity-bit (1-bit) - 32 bytes` (https://github.com/zcash/pasta)
		CurveType SignaturePublicKeyCurveType `json:"curve_type"`

		// HexBytes Hex-encoded public key bytes in the format
		// specified by the CurveType.
		HexBytes string `json:"hex_bytes"`
	} `json:"public_key"`

	// SignatureType SignatureType is the type of a cryptographic signature.
	//
	// * ecdsa: `r (32-bytes) || s (32-bytes)` - `64 bytes`
	// * ecdsa_recovery: `r (32-bytes) || s (32-bytes) || v (1-byte)` - `65 bytes`
	// * ed25519: `R (32-byte) || s (32-bytes)` - `64 bytes`
	// * schnorr_1: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (schnorr signature implemented by Zilliqa where both `r` and `s` are scalars encoded as `32-bytes` values, most significant byte first.)
	// * schnorr_bip340: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (sig = (bytes(R) || bytes((k + ed) mod n) where `r` is the `X` coordinate of a point `R` whose `Y` coordinate is even, most significant bytes first.)
	// * schnorr_poseidon: `r (32-bytes) || s (32-bytes)` where s = Hash(1st pk || 2nd pk || r) - `64 bytes`  (schnorr signature w/ Poseidon hash function implemented by O(1) Labs where both `r` and `s` are scalars encoded as `32-bytes` values, least significant byte first. https://github.com/CodaProtocol/signer-reference/blob/master/schnorr.ml )
	SignatureType SignatureSignatureType `json:"signature_type"`

	// SigningPayload SigningPayload is signed by the client with the keypair associated
	// with an AccountIdentifier using the specified SignatureType.
	//
	// SignatureType can be optionally populated if there is
	// a restriction on the signature scheme that can be
	// used to sign the payload.
	SigningPayload struct {
		// AccountIdentifier The account_identifier uniquely identifies an account within a network.
		// All fields in the account_identifier are utilized to determine this uniqueness
		// (including the metadata field, if populated).
		AccountIdentifier *struct {
			// Address The address may be a cryptographic public key (or some encoding of it) or a provided username.
			Address string `json:"address"`

			// Metadata Blockchains that utilize a username model (where the address is not a derivative of a cryptographic
			// public key) should specify the public key(s) owned by the address in metadata.
			Metadata *map[string]interface{} `json:"metadata,omitempty"`

			// SubAccount An account may have state specific to a contract address (ERC-20 token)
			// and/or a stake (delegated balance). The sub_account_identifier should
			// specify which state (if applicable) an account instantiation refers to.
			SubAccount *struct {
				// Address The SubAccount address may be a cryptographic value or some
				// other identifier (ex: bonded) that uniquely specifies a SubAccount.
				Address string `json:"address"`

				// Metadata If the SubAccount address is not sufficient to uniquely specify a SubAccount,
				// any other identifying information can be stored here.
				//
				// It is important to note that two SubAccounts with identical addresses but
				// differing metadata will not be considered equal by clients.
				Metadata *map[string]interface{} `json:"metadata,omitempty"`
			} `json:"sub_account,omitempty"`
		} `json:"account_identifier,omitempty"`

		// Address [DEPRECATED by `account_identifier` in `v1.4.4`] The network-specific address of the account that should sign
		// the payload.
		Address *string `json:"address,omitempty"`

		// HexBytes Hex-encoded string of the payload bytes.
		HexBytes string `json:"hex_bytes"`

		// SignatureType SignatureType is the type of a cryptographic signature.
		//
		// * ecdsa: `r (32-bytes) || s (32-bytes)` - `64 bytes`
		// * ecdsa_recovery: `r (32-bytes) || s (32-bytes) || v (1-byte)` - `65 bytes`
		// * ed25519: `R (32-byte) || s (32-bytes)` - `64 bytes`
		// * schnorr_1: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (schnorr signature implemented by Zilliqa where both `r` and `s` are scalars encoded as `32-bytes` values, most significant byte first.)
		// * schnorr_bip340: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (sig = (bytes(R) || bytes((k + ed) mod n) where `r` is the `X` coordinate of a point `R` whose `Y` coordinate is even, most significant bytes first.)
		// * schnorr_poseidon: `r (32-bytes) || s (32-bytes)` where s = Hash(1st pk || 2nd pk || r) - `64 bytes`  (schnorr signature w/ Poseidon hash function implemented by O(1) Labs where both `r` and `s` are scalars encoded as `32-bytes` values, least significant byte first. https://github.com/CodaProtocol/signer-reference/blob/master/schnorr.ml )
		SignatureType *SignatureSigningPayloadSignatureType `json:"signature_type,omitempty"`
	} `json:"signing_payload"`
}

// SignaturePublicKeyCurveType CurveType is the type of cryptographic curve associated with a PublicKey.
//
// * secp256k1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3)
// * secp256k1_bip340: x-only - `32 bytes`  (implicitly even `Y` coord. Secp256k1 compressed keys may be repurposed by dropping the first byte. (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Public_Key_Generation))
// * secp256r1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3)
// * edwards25519: `y (255-bits) || x-sign-bit (1-bit)` - `32 bytes` (https://ed25519.cr.yp.to/ed25519-20110926.pdf)
// * tweedle: 1st pk : Fq.t (32 bytes) || 2nd pk : Fq.t (32 bytes) (https://github.com/CodaProtocol/coda/blob/develop/rfcs/0038-rosetta-construction-api.md#marshal-keys)
// * pallas: `x (255 bits) || y-parity-bit (1-bit) - 32 bytes` (https://github.com/zcash/pasta)
type SignaturePublicKeyCurveType string

// SignatureSignatureType SignatureType is the type of a cryptographic signature.
//
// * ecdsa: `r (32-bytes) || s (32-bytes)` - `64 bytes`
// * ecdsa_recovery: `r (32-bytes) || s (32-bytes) || v (1-byte)` - `65 bytes`
// * ed25519: `R (32-byte) || s (32-bytes)` - `64 bytes`
// * schnorr_1: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (schnorr signature implemented by Zilliqa where both `r` and `s` are scalars encoded as `32-bytes` values, most significant byte first.)
// * schnorr_bip340: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (sig = (bytes(R) || bytes((k + ed) mod n) where `r` is the `X` coordinate of a point `R` whose `Y` coordinate is even, most significant bytes first.)
// * schnorr_poseidon: `r (32-bytes) || s (32-bytes)` where s = Hash(1st pk || 2nd pk || r) - `64 bytes`  (schnorr signature w/ Poseidon hash function implemented by O(1) Labs where both `r` and `s` are scalars encoded as `32-bytes` values, least significant byte first. https://github.com/CodaProtocol/signer-reference/blob/master/schnorr.ml )
type SignatureSignatureType string

// SignatureSigningPayloadSignatureType SignatureType is the type of a cryptographic signature.
//
// * ecdsa: `r (32-bytes) || s (32-bytes)` - `64 bytes`
// * ecdsa_recovery: `r (32-bytes) || s (32-bytes) || v (1-byte)` - `65 bytes`
// * ed25519: `R (32-byte) || s (32-bytes)` - `64 bytes`
// * schnorr_1: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (schnorr signature implemented by Zilliqa where both `r` and `s` are scalars encoded as `32-bytes` values, most significant byte first.)
// * schnorr_bip340: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (sig = (bytes(R) || bytes((k + ed) mod n) where `r` is the `X` coordinate of a point `R` whose `Y` coordinate is even, most significant bytes first.)
// * schnorr_poseidon: `r (32-bytes) || s (32-bytes)` where s = Hash(1st pk || 2nd pk || r) - `64 bytes`  (schnorr signature w/ Poseidon hash function implemented by O(1) Labs where both `r` and `s` are scalars encoded as `32-bytes` values, least significant byte first. https://github.com/CodaProtocol/signer-reference/blob/master/schnorr.ml )
type SignatureSigningPayloadSignatureType string

// SigningPayload SigningPayload is signed by the client with the keypair associated
// with an AccountIdentifier using the specified SignatureType.
//
// SignatureType can be optionally populated if there is
// a restriction on the signature scheme that can be
// used to sign the payload.
type SigningPayload struct {
	// AccountIdentifier The account_identifier uniquely identifies an account within a network.
	// All fields in the account_identifier are utilized to determine this uniqueness
	// (including the metadata field, if populated).
	AccountIdentifier *struct {
		// Address The address may be a cryptographic public key (or some encoding of it) or a provided username.
		Address string `json:"address"`

		// Metadata Blockchains that utilize a username model (where the address is not a derivative of a cryptographic
		// public key) should specify the public key(s) owned by the address in metadata.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// SubAccount An account may have state specific to a contract address (ERC-20 token)
		// and/or a stake (delegated balance). The sub_account_identifier should
		// specify which state (if applicable) an account instantiation refers to.
		SubAccount *struct {
			// Address The SubAccount address may be a cryptographic value or some
			// other identifier (ex: bonded) that uniquely specifies a SubAccount.
			Address string `json:"address"`

			// Metadata If the SubAccount address is not sufficient to uniquely specify a SubAccount,
			// any other identifying information can be stored here.
			//
			// It is important to note that two SubAccounts with identical addresses but
			// differing metadata will not be considered equal by clients.
			Metadata *map[string]interface{} `json:"metadata,omitempty"`
		} `json:"sub_account,omitempty"`
	} `json:"account_identifier,omitempty"`

	// Address [DEPRECATED by `account_identifier` in `v1.4.4`] The network-specific address of the account that should sign
	// the payload.
	Address *string `json:"address,omitempty"`

	// HexBytes Hex-encoded string of the payload bytes.
	HexBytes string `json:"hex_bytes"`

	// SignatureType SignatureType is the type of a cryptographic signature.
	//
	// * ecdsa: `r (32-bytes) || s (32-bytes)` - `64 bytes`
	// * ecdsa_recovery: `r (32-bytes) || s (32-bytes) || v (1-byte)` - `65 bytes`
	// * ed25519: `R (32-byte) || s (32-bytes)` - `64 bytes`
	// * schnorr_1: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (schnorr signature implemented by Zilliqa where both `r` and `s` are scalars encoded as `32-bytes` values, most significant byte first.)
	// * schnorr_bip340: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (sig = (bytes(R) || bytes((k + ed) mod n) where `r` is the `X` coordinate of a point `R` whose `Y` coordinate is even, most significant bytes first.)
	// * schnorr_poseidon: `r (32-bytes) || s (32-bytes)` where s = Hash(1st pk || 2nd pk || r) - `64 bytes`  (schnorr signature w/ Poseidon hash function implemented by O(1) Labs where both `r` and `s` are scalars encoded as `32-bytes` values, least significant byte first. https://github.com/CodaProtocol/signer-reference/blob/master/schnorr.ml )
	SignatureType *SigningPayloadSignatureType `json:"signature_type,omitempty"`
}

// SigningPayloadSignatureType SignatureType is the type of a cryptographic signature.
//
// * ecdsa: `r (32-bytes) || s (32-bytes)` - `64 bytes`
// * ecdsa_recovery: `r (32-bytes) || s (32-bytes) || v (1-byte)` - `65 bytes`
// * ed25519: `R (32-byte) || s (32-bytes)` - `64 bytes`
// * schnorr_1: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (schnorr signature implemented by Zilliqa where both `r` and `s` are scalars encoded as `32-bytes` values, most significant byte first.)
// * schnorr_bip340: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (sig = (bytes(R) || bytes((k + ed) mod n) where `r` is the `X` coordinate of a point `R` whose `Y` coordinate is even, most significant bytes first.)
// * schnorr_poseidon: `r (32-bytes) || s (32-bytes)` where s = Hash(1st pk || 2nd pk || r) - `64 bytes`  (schnorr signature w/ Poseidon hash function implemented by O(1) Labs where both `r` and `s` are scalars encoded as `32-bytes` values, least significant byte first. https://github.com/CodaProtocol/signer-reference/blob/master/schnorr.ml )
type SigningPayloadSignatureType string

// SyncStatus SyncStatus is used to provide additional context about an
// implementation's sync status.
//
// This object is often used by implementations to indicate healthiness
// when block data cannot be queried until some sync phase completes or
// cannot be determined by comparing the timestamp of the most recent
// block with the current time.
type SyncStatus struct {
	// CurrentIndex CurrentIndex is the index of the last synced block in the
	// current stage.
	//
	// This is a separate field from current_block_identifier in
	// NetworkStatusResponse because blocks with indices up to and including
	// the current_index may not yet be queryable by the caller. To reiterate,
	// all indices up to and including current_block_identifier in
	// NetworkStatusResponse must be queryable via the /block endpoint (excluding
	// indices less than oldest_block_identifier).
	CurrentIndex *int64 `json:"current_index,omitempty"`

	// Stage Stage is the phase of the sync process.
	Stage *string `json:"stage,omitempty"`

	// Synced synced is a boolean that indicates if an implementation has synced up
	// to the most recent block. If this field is not populated, the caller
	// should rely on a traditional tip timestamp comparison to determine if
	// an implementation is synced.
	//
	// This field is particularly useful for quiescent blockchains (blocks
	// only produced when there are pending transactions). In these blockchains,
	// the most recent block could have a timestamp far behind the current
	// time but the node could be healthy and at tip.
	Synced *bool `json:"synced,omitempty"`

	// TargetIndex TargetIndex is the index of the block that the implementation
	// is attempting to sync to in the current stage.
	TargetIndex *int64 `json:"target_index,omitempty"`
}

// Timestamp The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in
// milliseconds because some blockchains produce blocks more often than once a second.
type Timestamp = int64

// Transaction Transactions contain an array of Operations
// that are attributable to the same TransactionIdentifier.
type Transaction struct {
	// Metadata Transactions that are related to other transactions (like a cross-shard transaction) should include
	// the tranaction_identifier of these transactions in the metadata.
	Metadata   *map[string]interface{} `json:"metadata,omitempty"`
	Operations []struct {
		// Account The account_identifier uniquely identifies an account within a network.
		// All fields in the account_identifier are utilized to determine this uniqueness
		// (including the metadata field, if populated).
		Account *struct {
			// Address The address may be a cryptographic public key (or some encoding of it) or a provided username.
			Address string `json:"address"`

			// Metadata Blockchains that utilize a username model (where the address is not a derivative of a cryptographic
			// public key) should specify the public key(s) owned by the address in metadata.
			Metadata *map[string]interface{} `json:"metadata,omitempty"`

			// SubAccount An account may have state specific to a contract address (ERC-20 token)
			// and/or a stake (delegated balance). The sub_account_identifier should
			// specify which state (if applicable) an account instantiation refers to.
			SubAccount *struct {
				// Address The SubAccount address may be a cryptographic value or some
				// other identifier (ex: bonded) that uniquely specifies a SubAccount.
				Address string `json:"address"`

				// Metadata If the SubAccount address is not sufficient to uniquely specify a SubAccount,
				// any other identifying information can be stored here.
				//
				// It is important to note that two SubAccounts with identical addresses but
				// differing metadata will not be considered equal by clients.
				Metadata *map[string]interface{} `json:"metadata,omitempty"`
			} `json:"sub_account,omitempty"`
		} `json:"account,omitempty"`

		// Amount Amount is some Value of a Currency.
		// It is considered invalid to specify a Value without a Currency.
		Amount *struct {
			// Currency Currency is composed of a canonical Symbol and
			// Decimals. This Decimals value is used to convert
			// an Amount.Value from atomic units (Satoshis) to standard units
			// (Bitcoins).
			Currency struct {
				// Decimals Number of decimal places in the standard unit representation of the amount.
				//
				// For example, BTC has 8 decimals. Note that it is not possible to represent
				// the value of some currency in atomic units that is not base 10.
				Decimals int32 `json:"decimals"`

				// Metadata Any additional information related to the currency itself.
				//
				// For example, it would be useful to populate this object with the contract address
				// of an ERC-20 token.
				Metadata *map[string]interface{} `json:"metadata,omitempty"`

				// Symbol Canonical symbol associated with a currency.
				Symbol string `json:"symbol"`
			} `json:"currency"`
			Metadata *map[string]interface{} `json:"metadata,omitempty"`

			// Value Value of the transaction in atomic units represented as an arbitrary-sized signed integer.
			//
			// For example, 1 BTC would be represented by a value of 100000000.
			Value string `json:"value"`
		} `json:"amount,omitempty"`

		// CoinChange CoinChange is used to represent a change in state of
		// a some coin identified by a coin_identifier. This object
		// is part of the Operation model and must be populated for
		// UTXO-based blockchains.
		//
		// Coincidentally, this abstraction of UTXOs allows for supporting
		// both account-based transfers and UTXO-based transfers on the
		// same blockchain (when a transfer is account-based, don't
		// populate this model).
		CoinChange *struct {
			// CoinAction CoinActions are different state changes that a Coin can
			// undergo. When a Coin is created, it is coin_created. When a Coin is
			// spent, it is coin_spent. It is assumed that a single Coin
			// cannot be created or spent more than once.
			CoinAction TransactionOperationsCoinChangeCoinAction `json:"coin_action"`

			// CoinIdentifier CoinIdentifier uniquely identifies a Coin.
			CoinIdentifier struct {
				// Identifier Identifier should be populated with a globally unique identifier
				// of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
				Identifier string `json:"identifier"`
			} `json:"coin_identifier"`
		} `json:"coin_change,omitempty"`
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// OperationIdentifier The operation_identifier uniquely identifies an operation within a transaction.
		OperationIdentifier struct {
			// Index The operation index is used to ensure each operation has a unique identifier within
			// a transaction. This index is only relative to the transaction and NOT GLOBAL. The
			// operations in each transaction should start from index 0.
			//
			// To clarify, there may not be any notion of an operation index in the blockchain being described.
			Index int64 `json:"index"`

			// NetworkIndex Some blockchains specify an operation index that is essential for client use. For example,
			// Bitcoin uses a network_index to identify which UTXO was used in a transaction.
			//
			// network_index should not be populated if there is no notion of an operation index in a
			// blockchain (typically most account-based blockchains).
			NetworkIndex *int64 `json:"network_index,omitempty"`
		} `json:"operation_identifier"`

		// RelatedOperations Restrict referenced related_operations to identifier indices
		// < the current operation_identifier.index. This ensures there
		// exists a clear DAG-structure of relations.
		//
		// Since operations are one-sided, one could imagine relating operations
		// in a single transfer or linking operations in a call tree.
		RelatedOperations *[]struct {
			// Index The operation index is used to ensure each operation has a unique identifier within
			// a transaction. This index is only relative to the transaction and NOT GLOBAL. The
			// operations in each transaction should start from index 0.
			//
			// To clarify, there may not be any notion of an operation index in the blockchain being described.
			Index int64 `json:"index"`

			// NetworkIndex Some blockchains specify an operation index that is essential for client use. For example,
			// Bitcoin uses a network_index to identify which UTXO was used in a transaction.
			//
			// network_index should not be populated if there is no notion of an operation index in a
			// blockchain (typically most account-based blockchains).
			NetworkIndex *int64 `json:"network_index,omitempty"`
		} `json:"related_operations,omitempty"`

		// Status Status is the network-specific status of the operation. Status is not defined on the transaction object
		// because blockchains with smart contracts may have transactions that partially apply (some operations
		// are successful and some are not). Blockchains with atomic transactions (all operations succeed or
		// all operations fail) will have the same status for each operation.
		//
		// On-chain operations (operations retrieved in the `/block` and `/block/transaction` endpoints) MUST have
		// a populated status field (anything on-chain must have succeeded or failed). However, operations provided
		// during transaction construction (often times called "intent" in the documentation) MUST NOT
		// have a populated status field (operations yet to be included on-chain have not yet succeeded or failed).
		Status *string `json:"status,omitempty"`

		// Type Type is the network-specific type of the operation. Ensure that any type that can be returned here is also
		// specified in the NetworkOptionsResponse. This can be very useful to downstream consumers that parse all
		// block data.
		Type string `json:"type"`
	} `json:"operations"`
	RelatedTransactions *[]struct {
		// Direction Used by RelatedTransaction to indicate the direction of the relation (i.e. cross-shard/cross-network sends may
		// reference `backward` to an earlier transaction and async execution may reference `forward`). Can be used to indicate if
		// a transaction relation is from child to parent or the reverse.
		Direction TransactionRelatedTransactionsDirection `json:"direction"`

		// NetworkIdentifier The network_identifier specifies which network a particular object is associated with.
		NetworkIdentifier *struct {
			Blockchain string `json:"blockchain"`

			// Network If a blockchain has a specific chain-id or network identifier, it
			// should go in this field. It is up to the client to determine which
			// network-specific identifier is mainnet or testnet.
			Network string `json:"network"`

			// SubNetworkIdentifier In blockchains with sharded state, the SubNetworkIdentifier
			// is required to query some object on a specific shard. This identifier is
			// optional for all non-sharded blockchains.
			SubNetworkIdentifier *struct {
				Metadata *map[string]interface{} `json:"metadata,omitempty"`
				Network  string                  `json:"network"`
			} `json:"sub_network_identifier,omitempty"`
		} `json:"network_identifier,omitempty"`

		// TransactionIdentifier The transaction_identifier uniquely identifies a transaction in a particular network and block
		// or in the mempool.
		TransactionIdentifier struct {
			// Hash Any transactions that are attributable only to a block (ex: a block event)
			// should use the hash of the block as the identifier.  This should be normalized according to
			// the case specified in the transaction_hash_case in network options.
			Hash string `json:"hash"`
		} `json:"transaction_identifier"`
	} `json:"related_transactions,omitempty"`

	// TransactionIdentifier The transaction_identifier uniquely identifies a transaction in a particular network and block
	// or in the mempool.
	TransactionIdentifier struct {
		// Hash Any transactions that are attributable only to a block (ex: a block event)
		// should use the hash of the block as the identifier.  This should be normalized according to
		// the case specified in the transaction_hash_case in network options.
		Hash string `json:"hash"`
	} `json:"transaction_identifier"`
}

// TransactionOperationsCoinChangeCoinAction CoinActions are different state changes that a Coin can
// undergo. When a Coin is created, it is coin_created. When a Coin is
// spent, it is coin_spent. It is assumed that a single Coin
// cannot be created or spent more than once.
type TransactionOperationsCoinChangeCoinAction string

// TransactionRelatedTransactionsDirection Used by RelatedTransaction to indicate the direction of the relation (i.e. cross-shard/cross-network sends may
// reference `backward` to an earlier transaction and async execution may reference `forward`). Can be used to indicate if
// a transaction relation is from child to parent or the reverse.
type TransactionRelatedTransactionsDirection string

// TransactionIdentifier The transaction_identifier uniquely identifies a transaction in a particular network and block
// or in the mempool.
type TransactionIdentifier struct {
	// Hash Any transactions that are attributable only to a block (ex: a block event)
	// should use the hash of the block as the identifier.  This should be normalized according to
	// the case specified in the transaction_hash_case in network options.
	Hash string `json:"hash"`
}

// TransactionIdentifierResponse TransactionIdentifierResponse contains the transaction_identifier of a
// transaction that was submitted to either `/construction/hash` or
// `/construction/submit`.
type TransactionIdentifierResponse struct {
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// TransactionIdentifier The transaction_identifier uniquely identifies a transaction in a particular network and block
	// or in the mempool.
	TransactionIdentifier TransactionIdentifier `json:"transaction_identifier"`
}

// Version The Version object is utilized to inform the client
// of the versions of different components of the Rosetta
// implementation.
type Version struct {
	// Metadata Any other information that may be useful about versioning
	// of dependent services should be returned here.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MiddlewareVersion When a middleware server is used to adhere to the Rosetta
	// interface, it should return its version here. This can help
	// clients manage deployments.
	MiddlewareVersion *string `json:"middleware_version,omitempty"`

	// NodeVersion The node_version is the canonical version of the node
	// runtime. This can help clients manage deployments.
	NodeVersion string `json:"node_version"`

	// RosettaVersion The rosetta_version is the version of the Rosetta interface
	// the implementation adheres to. This can be useful for clients
	// looking to reliably parse responses.
	RosettaVersion string `json:"rosetta_version"`
}

// AccountBalanceJSONRequestBody defines body for AccountBalance for application/json ContentType.
type AccountBalanceJSONRequestBody = AccountBalanceRequest

// AccountCoinsJSONRequestBody defines body for AccountCoins for application/json ContentType.
type AccountCoinsJSONRequestBody = AccountCoinsRequest

// BlockJSONRequestBody defines body for Block for application/json ContentType.
type BlockJSONRequestBody = BlockRequest

// BlockTransactionJSONRequestBody defines body for BlockTransaction for application/json ContentType.
type BlockTransactionJSONRequestBody = BlockTransactionRequest

// CallJSONRequestBody defines body for Call for application/json ContentType.
type CallJSONRequestBody = CallRequest

// ConstructionCombineJSONRequestBody defines body for ConstructionCombine for application/json ContentType.
type ConstructionCombineJSONRequestBody = ConstructionCombineRequest

// ConstructionDeriveJSONRequestBody defines body for ConstructionDerive for application/json ContentType.
type ConstructionDeriveJSONRequestBody = ConstructionDeriveRequest

// ConstructionHashJSONRequestBody defines body for ConstructionHash for application/json ContentType.
type ConstructionHashJSONRequestBody = ConstructionHashRequest

// ConstructionMetadataJSONRequestBody defines body for ConstructionMetadata for application/json ContentType.
type ConstructionMetadataJSONRequestBody = ConstructionMetadataRequest

// ConstructionParseJSONRequestBody defines body for ConstructionParse for application/json ContentType.
type ConstructionParseJSONRequestBody = ConstructionParseRequest

// ConstructionPayloadsJSONRequestBody defines body for ConstructionPayloads for application/json ContentType.
type ConstructionPayloadsJSONRequestBody = ConstructionPayloadsRequest

// ConstructionPreprocessJSONRequestBody defines body for ConstructionPreprocess for application/json ContentType.
type ConstructionPreprocessJSONRequestBody = ConstructionPreprocessRequest

// ConstructionSubmitJSONRequestBody defines body for ConstructionSubmit for application/json ContentType.
type ConstructionSubmitJSONRequestBody = ConstructionSubmitRequest

// EventsBlocksJSONRequestBody defines body for EventsBlocks for application/json ContentType.
type EventsBlocksJSONRequestBody = EventsBlocksRequest

// MempoolJSONRequestBody defines body for Mempool for application/json ContentType.
type MempoolJSONRequestBody = NetworkRequest

// MempoolTransactionJSONRequestBody defines body for MempoolTransaction for application/json ContentType.
type MempoolTransactionJSONRequestBody = MempoolTransactionRequest

// NetworkListJSONRequestBody defines body for NetworkList for application/json ContentType.
type NetworkListJSONRequestBody = MetadataRequest

// NetworkOptionsJSONRequestBody defines body for NetworkOptions for application/json ContentType.
type NetworkOptionsJSONRequestBody = NetworkRequest

// NetworkStatusJSONRequestBody defines body for NetworkStatus for application/json ContentType.
type NetworkStatusJSONRequestBody = NetworkRequest

// SearchTransactionsJSONRequestBody defines body for SearchTransactions for application/json ContentType.
type SearchTransactionsJSONRequestBody = SearchTransactionsRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get an Account's Balance
	// (POST /account/balance)
	AccountBalance(w http.ResponseWriter, r *http.Request)
	// Get an Account's Unspent Coins
	// (POST /account/coins)
	AccountCoins(w http.ResponseWriter, r *http.Request)
	// Get a Block
	// (POST /block)
	Block(w http.ResponseWriter, r *http.Request)
	// Get a Block Transaction
	// (POST /block/transaction)
	BlockTransaction(w http.ResponseWriter, r *http.Request)
	// Make a Network-Specific Procedure Call
	// (POST /call)
	Call(w http.ResponseWriter, r *http.Request)
	// Create Network Transaction from Signatures
	// (POST /construction/combine)
	ConstructionCombine(w http.ResponseWriter, r *http.Request)
	// Derive an AccountIdentifier from a PublicKey
	// (POST /construction/derive)
	ConstructionDerive(w http.ResponseWriter, r *http.Request)
	// Get the Hash of a Signed Transaction
	// (POST /construction/hash)
	ConstructionHash(w http.ResponseWriter, r *http.Request)
	// Get Metadata for Transaction Construction
	// (POST /construction/metadata)
	ConstructionMetadata(w http.ResponseWriter, r *http.Request)
	// Parse a Transaction
	// (POST /construction/parse)
	ConstructionParse(w http.ResponseWriter, r *http.Request)
	// Generate an Unsigned Transaction and Signing Payloads
	// (POST /construction/payloads)
	ConstructionPayloads(w http.ResponseWriter, r *http.Request)
	// Create a Request to Fetch Metadata
	// (POST /construction/preprocess)
	ConstructionPreprocess(w http.ResponseWriter, r *http.Request)
	// Submit a Signed Transaction
	// (POST /construction/submit)
	ConstructionSubmit(w http.ResponseWriter, r *http.Request)
	// [INDEXER] Get a range of BlockEvents
	// (POST /events/blocks)
	EventsBlocks(w http.ResponseWriter, r *http.Request)
	// Get All Mempool Transactions
	// (POST /mempool)
	Mempool(w http.ResponseWriter, r *http.Request)
	// Get a Mempool Transaction
	// (POST /mempool/transaction)
	MempoolTransaction(w http.ResponseWriter, r *http.Request)
	// Get List of Available Networks
	// (POST /network/list)
	NetworkList(w http.ResponseWriter, r *http.Request)
	// Get Network Options
	// (POST /network/options)
	NetworkOptions(w http.ResponseWriter, r *http.Request)
	// Get Network Status
	// (POST /network/status)
	NetworkStatus(w http.ResponseWriter, r *http.Request)
	// [INDEXER] Search for Transactions
	// (POST /search/transactions)
	SearchTransactions(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Get an Account's Balance
// (POST /account/balance)
func (_ Unimplemented) AccountBalance(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get an Account's Unspent Coins
// (POST /account/coins)
func (_ Unimplemented) AccountCoins(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a Block
// (POST /block)
func (_ Unimplemented) Block(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a Block Transaction
// (POST /block/transaction)
func (_ Unimplemented) BlockTransaction(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Make a Network-Specific Procedure Call
// (POST /call)
func (_ Unimplemented) Call(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create Network Transaction from Signatures
// (POST /construction/combine)
func (_ Unimplemented) ConstructionCombine(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Derive an AccountIdentifier from a PublicKey
// (POST /construction/derive)
func (_ Unimplemented) ConstructionDerive(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get the Hash of a Signed Transaction
// (POST /construction/hash)
func (_ Unimplemented) ConstructionHash(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get Metadata for Transaction Construction
// (POST /construction/metadata)
func (_ Unimplemented) ConstructionMetadata(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Parse a Transaction
// (POST /construction/parse)
func (_ Unimplemented) ConstructionParse(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Generate an Unsigned Transaction and Signing Payloads
// (POST /construction/payloads)
func (_ Unimplemented) ConstructionPayloads(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a Request to Fetch Metadata
// (POST /construction/preprocess)
func (_ Unimplemented) ConstructionPreprocess(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Submit a Signed Transaction
// (POST /construction/submit)
func (_ Unimplemented) ConstructionSubmit(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// [INDEXER] Get a range of BlockEvents
// (POST /events/blocks)
func (_ Unimplemented) EventsBlocks(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get All Mempool Transactions
// (POST /mempool)
func (_ Unimplemented) Mempool(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a Mempool Transaction
// (POST /mempool/transaction)
func (_ Unimplemented) MempoolTransaction(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get List of Available Networks
// (POST /network/list)
func (_ Unimplemented) NetworkList(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get Network Options
// (POST /network/options)
func (_ Unimplemented) NetworkOptions(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get Network Status
// (POST /network/status)
func (_ Unimplemented) NetworkStatus(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// [INDEXER] Search for Transactions
// (POST /search/transactions)
func (_ Unimplemented) SearchTransactions(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AccountBalance operation middleware
func (siw *ServerInterfaceWrapper) AccountBalance(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountBalance(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AccountCoins operation middleware
func (siw *ServerInterfaceWrapper) AccountCoins(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountCoins(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Block operation middleware
func (siw *ServerInterfaceWrapper) Block(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Block(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// BlockTransaction operation middleware
func (siw *ServerInterfaceWrapper) BlockTransaction(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BlockTransaction(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Call operation middleware
func (siw *ServerInterfaceWrapper) Call(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Call(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ConstructionCombine operation middleware
func (siw *ServerInterfaceWrapper) ConstructionCombine(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ConstructionCombine(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ConstructionDerive operation middleware
func (siw *ServerInterfaceWrapper) ConstructionDerive(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ConstructionDerive(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ConstructionHash operation middleware
func (siw *ServerInterfaceWrapper) ConstructionHash(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ConstructionHash(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ConstructionMetadata operation middleware
func (siw *ServerInterfaceWrapper) ConstructionMetadata(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ConstructionMetadata(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ConstructionParse operation middleware
func (siw *ServerInterfaceWrapper) ConstructionParse(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ConstructionParse(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ConstructionPayloads operation middleware
func (siw *ServerInterfaceWrapper) ConstructionPayloads(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ConstructionPayloads(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ConstructionPreprocess operation middleware
func (siw *ServerInterfaceWrapper) ConstructionPreprocess(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ConstructionPreprocess(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ConstructionSubmit operation middleware
func (siw *ServerInterfaceWrapper) ConstructionSubmit(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ConstructionSubmit(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// EventsBlocks operation middleware
func (siw *ServerInterfaceWrapper) EventsBlocks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EventsBlocks(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Mempool operation middleware
func (siw *ServerInterfaceWrapper) Mempool(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Mempool(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// MempoolTransaction operation middleware
func (siw *ServerInterfaceWrapper) MempoolTransaction(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MempoolTransaction(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// NetworkList operation middleware
func (siw *ServerInterfaceWrapper) NetworkList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.NetworkList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// NetworkOptions operation middleware
func (siw *ServerInterfaceWrapper) NetworkOptions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.NetworkOptions(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// NetworkStatus operation middleware
func (siw *ServerInterfaceWrapper) NetworkStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.NetworkStatus(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// SearchTransactions operation middleware
func (siw *ServerInterfaceWrapper) SearchTransactions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchTransactions(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/account/balance", wrapper.AccountBalance)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/account/coins", wrapper.AccountCoins)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/block", wrapper.Block)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/block/transaction", wrapper.BlockTransaction)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/call", wrapper.Call)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/construction/combine", wrapper.ConstructionCombine)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/construction/derive", wrapper.ConstructionDerive)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/construction/hash", wrapper.ConstructionHash)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/construction/metadata", wrapper.ConstructionMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/construction/parse", wrapper.ConstructionParse)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/construction/payloads", wrapper.ConstructionPayloads)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/construction/preprocess", wrapper.ConstructionPreprocess)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/construction/submit", wrapper.ConstructionSubmit)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/events/blocks", wrapper.EventsBlocks)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mempool", wrapper.Mempool)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/mempool/transaction", wrapper.MempoolTransaction)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/network/list", wrapper.NetworkList)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/network/options", wrapper.NetworkOptions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/network/status", wrapper.NetworkStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/search/transactions", wrapper.SearchTransactions)
	})

	return r
}
